#if !EXCLUDE_PAGE_RELEASENOTES
@page "/projects/{ProjectName}/release-notes"
@using System.Text
@using System.Text.Json
@using System.Text.Json.Serialization
@using DevOpsAssistant.Services
@using DevOpsAssistant.Services.Models
@using DevOpsAssistant.Utils
@using MudBlazor
@inject DevOpsApiService ApiService
@inject IJSRuntime JS
@inject PageStateService StateService
@inherits ProjectComponentBase
@inject ISnackbar Snackbar
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<ReleaseNotes> L

<PageTitle>DevOpsAssistant - Release Notes</PageTitle>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error">@_error</MudAlert>
}

<MudExpansionPanels>
    <MudExpansionPanel Text="Options" Expanded="@_filtersExpanded" ExpandedChanged="@(v => OnFilterPanelChanged(v))">
        <MudPaper>
            <MudStack Spacing="2">
                <MudSwitch T="bool" Value="_treeView" ValueChanged="OnTreeViewChanged" Color="Color.Primary" Label="Tree View" />
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                    @if (_treeView)
                    {
                        <MudSelect T="string" @bind-Value="_path" Label="Backlog">
                            @foreach (var b in _backlogs)
                            {
                                <MudSelectItem Value="@b">@b</MudSelectItem>
                            }
                        </MudSelect>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="_loading" OnClick="Load">Load</MudButton>
                    }
                    else
                    {
                        <MudAutocomplete T="WorkItemInfo"
                                         Label="Work Items"
                                         Placeholder="@L["AutocompletePlaceholder"]"
                                         SearchFunc="SearchItems"
                                         ToStringFunc="@(s => $"{s.Id} - {s.Title}")"
                                         Value="_searchValue"
                                         ValueChanged="OnItemSelected" />
                    }
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="_loading" OnClick="Generate">Generate Prompt</MudButton>
                    <MudButton Variant="Variant.Outlined" OnClick="Reset">Reset</MudButton>
                </MudStack>
            </MudStack>
        </MudPaper>
    </MudExpansionPanel>
</MudExpansionPanels>

@if (_treeView)
{
    <MudTextField T="string" Label="Filter" Value="_filter" Immediate="true" ValueChanged="OnFilterChanged" Class="mb-2" />
}

@if (_treeView && _displayTreeItems != null)
{
    <MudTreeView T="WorkItemNode"
                 Items="@_displayTreeItems"
                 SelectionMode="SelectionMode.MultiSelection"
                 SelectedValues="@_selectedNodes"
                 SelectedValuesChanged="OnNodesSelected"
                 Class="scroll-300 work-item-tree">
        <ItemTemplate>
            <MudTreeViewItem Items="@context.Children"
                             Value="@context.Value"
                             Text="@($"{context.Value!.Info.Id} - {context.Value!.Info.Title}")"
                             Class="@WorkItemHelpers.GetItemClass(context.Value!.Info.WorkItemType)"
                             @bind-Expanded="@context.Expanded" />
        </ItemTemplate>
    </MudTreeView>
}

@if (_selectedItems.Any() && !_treeView)
{
    <MudTable Items="_selectedItems" Dense="true">
        <HeaderContent>
            <MudTh>ID</MudTh>
            <MudTh>Title</MudTh>
            <MudTh></MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="ID">@context.Id</MudTd>
            <MudTd DataLabel="Title">@context.Title</MudTd>
            <MudTd>
                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                               Color="Color.Error"
                               Size="Size.Small"
                               OnClick="() => Remove(context)"/>
            </MudTd>
        </RowTemplate>
    </MudTable>
}

@if (_loading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true"/>
}
else if (_promptParts != null)
{
    <MudPaper Class="pa-6">
        <MudStack Spacing="2">
            <MudButton Variant="Variant.Text"
                       StartIcon="@Icons.Material.Filled.Download"
                       OnClick="DownloadPrompt">
                Download
            </MudButton>
            <MudTextField T="string"
                          Text="@_promptParts[_partIndex]"
                          Lines="10"
                          ReadOnly="true"
                          />
            <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                <MudIconButton Icon="@Icons.Material.Filled.ChevronLeft"
                               Disabled="_partIndex == 0"
                               OnClick="PrevPart" />
                <MudText Typo="Typo.body2">@($"Part {_partIndex + 1}/{_promptParts.Count}")</MudText>
                <MudIconButton Icon="@Icons.Material.Filled.ChevronRight"
                               Disabled="_partIndex == _promptParts.Count - 1"
                               OnClick="NextPart" />
                <MudButton Variant="Variant.Text"
                           StartIcon="@Icons.Material.Filled.ContentCopy"
                           OnClick="() => CopyPart(_promptParts[_partIndex])">
                    Copy
                </MudButton>
            </MudStack>
        </MudStack>
    </MudPaper>
}

@code {
    [Parameter] public string ProjectName { get; set; } = string.Empty;
    private readonly HashSet<WorkItemInfo> _selectedItems = [];
    private WorkItemInfo? _searchValue;
    private bool _loading;
    private string? _prompt;
    private List<string>? _promptParts;
    private int _partIndex;
    private string? _error;
    private string _path = string.Empty;
    private string[] _backlogs = [];
    private List<TreeItemData<WorkItemNode>>? _treeItems;
    private List<TreeItemData<WorkItemNode>>? _displayTreeItems;
    private IReadOnlyCollection<WorkItemNode>? _selectedNodes;
    private bool _treeView;
    private string _filter = string.Empty;
    private bool _filtersExpanded = true;
    private const string StateKey = "release-notes";

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAsync();
        if (!string.IsNullOrWhiteSpace(ProjectName) &&
            ConfigService.CurrentProject.Name != ProjectName)
        {
            await ConfigService.SelectProjectAsync(ProjectName);
        }
        var state = await StateService.LoadAsync<PageState>(StateKey);
        if (state != null)
        {
            if (!string.IsNullOrWhiteSpace(state.Path))
                _path = state.Path;
            _treeView = state.TreeView;
        }
        if (_treeView)
        {
            await LoadBacklogs();
        }
    }

    private async Task LoadBacklogs()
    {
        try
        {
            _backlogs = await ApiService.GetBacklogsAsync();
            if (_backlogs.Length > 0 && string.IsNullOrWhiteSpace(_path))
                _path = _backlogs[0];
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task OnTreeViewChanged(bool value)
    {
        _treeView = value;
        if (_treeView && _backlogs.Length == 0)
        {
            await LoadBacklogs();
        }
        await StateService.SaveAsync(StateKey, new PageState { Path = _path, TreeView = _treeView });
    }

    private async Task Load()
    {
        _loading = true;
        StateHasChanged();
        try
        {
            var roots = await ApiService.GetWorkItemHierarchyAsync(_path);
            _treeItems = roots.Select(BuildTreeItem).ToList();
            ApplyFilter();
            await StateService.SaveAsync(StateKey, new PageState { Path = _path, TreeView = _treeView });
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private Task OnNodesSelected(IReadOnlyCollection<WorkItemNode> nodes)
    {
        _selectedNodes = nodes;
        _selectedItems.Clear();
        foreach (var n in nodes)
            _selectedItems.Add(n.Info);
        return Task.CompletedTask;
    }

    private async Task<IEnumerable<WorkItemInfo>> SearchItems(string value, CancellationToken _)
    {
        if (string.IsNullOrWhiteSpace(value) || value.Length < 2)
            return Array.Empty<WorkItemInfo>();
        try
        {
            var result = await ApiService.SearchReleaseItemsAsync(value);
            _error = null;
            return result.Where(r => !_selectedItems.Contains(r));
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            return Array.Empty<WorkItemInfo>();
        }
    }

    private void OnItemSelected(WorkItemInfo? item)
    {
        if (item != null)
            _selectedItems.Add(item);
        _searchValue = null;
        StateHasChanged();
    }

    private void Remove(WorkItemInfo story)
    {
        _selectedItems.Remove(story);
        StateHasChanged();
    }

    private void OnFilterPanelChanged(bool expanded)
    {
        _filtersExpanded = expanded;
    }

    private void OnFilterChanged(string value)
    {
        _filter = value;
        ApplyFilter();
    }

    private void ApplyFilter()
    {
        if (_treeItems == null)
        {
            _displayTreeItems = null;
            return;
        }

        if (string.IsNullOrWhiteSpace(_filter))
        {
            _displayTreeItems = _treeItems;
            return;
        }

        _displayTreeItems = _treeItems
            .Select(i => FilterNode(i, _filter))
            .Where(i => i != null)
            .ToList()!;
    }

    private static TreeItemData<WorkItemNode>? FilterNode(TreeItemData<WorkItemNode> item, string filter)
    {
        var match = item.Value!.Info.Id.ToString().Contains(filter, StringComparison.OrdinalIgnoreCase) ||
                    item.Value.Info.Title.Contains(filter, StringComparison.OrdinalIgnoreCase);
        List<TreeItemData<WorkItemNode>>? children = null;
        if (item.Children != null)
        {
            children = item.Children
                .Select(c => FilterNode(c, filter))
                .Where(c => c != null)
                .ToList()!;
        }

        if (match || (children != null && children.Count > 0))
        {
            var copy = new TreeItemData<WorkItemNode>
            {
                Value = item.Value,
                Text = item.Text,
                Children = children
            };
            if (!string.IsNullOrWhiteSpace(filter) && children != null && children.Count > 0)
                copy.Expanded = true;
            return copy;
        }
        return null;
    }

    private async Task Generate()
    {
        if (_selectedItems.Count == 0) return;
        _loading = true;
        StateHasChanged();
        try
        {
            var ids = _selectedItems.Select(s => s.Id);
            var details = await ApiService.GetStoryHierarchyDetailsAsync(ids);
            _prompt = BuildPrompt(details, ConfigService.Config);
            _promptParts = PromptHelpers.SplitPrompt(_prompt, ConfigService.Config.PromptCharacterLimit).ToList();
            _partIndex = 0;
            _error = null;
            await CopyPrompt();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private static TreeItemData<WorkItemNode> BuildTreeItem(WorkItemNode node)
    {
        var item = new TreeItemData<WorkItemNode>
        {
            Value = node,
            Text = $"{node.Info.Id} - {node.Info.Title}"
        };
        if (node.Children.Count > 0)
            item.Children = node.Children.Select(BuildTreeItem).ToList();
        return item;
    }

    private async Task CopyPrompt()
    {
        if (!string.IsNullOrWhiteSpace(_prompt))
        {
            await JS.InvokeVoidAsync("copyText", _prompt);
            Snackbar.Add(L["CopyToast"].Value, Severity.Success);
        }
    }

    private async Task CopyPart(string text)
    {
        await JS.InvokeVoidAsync("copyText", text);
        Snackbar.Add(L["CopyToast"].Value, Severity.Success);
    }

    private void PrevPart()
    {
        if (_partIndex > 0)
            _partIndex--;
    }

    private void NextPart()
    {
        if (_promptParts != null && _partIndex < _promptParts.Count - 1)
            _partIndex++;
    }

    private async Task DownloadPrompt()
    {
        if (!string.IsNullOrWhiteSpace(_prompt))
            await JS.InvokeVoidAsync("downloadText", "prompt.txt", _prompt);
    }

    private async Task Reset()
    {
        if (_treeView && _backlogs.Length > 0)
            _path = _backlogs[0];
        _selectedItems.Clear();
        _treeItems = null;
        _displayTreeItems = null;
        _selectedNodes = null;
        _filter = string.Empty;
        _filtersExpanded = true;
        _prompt = null;
        _promptParts = null;
        _partIndex = 0;
        await StateService.ClearAsync(StateKey);
        StateHasChanged();
    }

    private class PageState
    {
        public string Path { get; set; } = string.Empty;
        public bool TreeView { get; set; }
    }

    private static string BuildPrompt(IEnumerable<StoryHierarchyDetails> details, DevOpsConfig config)
    {
        var hierarchy = details.Select(d => new
        {
            Epic = d.Epic == null
                ? null
                : new
                {
                    d.Epic.Id,
                    d.Epic.Title,
                    Description = TextHelpers.Sanitize(d.EpicDescription)
                },
            Feature = d.Feature == null
                ? null
                : new
                {
                    d.Feature.Id,
                    d.Feature.Title,
                    Description = TextHelpers.Sanitize(d.FeatureDescription)
                },
            Item = new
            {
                d.Story.Id,
                d.Story.Title,
                d.Story.WorkItemType,
                Description = TextHelpers.Sanitize(d.Description),
                ReproSteps = config.Rules.Bug.IncludeReproSteps ? TextHelpers.Sanitize(d.ReproSteps) : null,
                SystemInfo = config.Rules.Bug.IncludeSystemInfo ? TextHelpers.Sanitize(d.SystemInfo) : null,
                AcceptanceCriteria = TextHelpers.Sanitize(d.AcceptanceCriteria)
            }
        });

        var json = JsonSerializer.Serialize(
            hierarchy,
            new JsonSerializerOptions
            {
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            });

        var sb = new StringBuilder();

        if (string.IsNullOrWhiteSpace(config.ReleaseNotesPrompt))
        {
            sb.AppendLine("You are a meticulous Delivery Manager preparing release notes for a software update.");
            sb.AppendLine("Write in clear, plain language so non-technical stakeholders can understand the changes.");
            sb.AppendLine();
            sb.AppendLine("Document sections:");
            sb.AppendLine("- Release Notes: a high-level summary of all stories in 1â€“2 paragraphs.");
            sb.AppendLine("- Change Control: a short summary, list of stories, and potential risks.");
            sb.AppendLine("- No branding is required.");
            sb.AppendLine();
            sb.AppendLine("Guidelines:");
            sb.AppendLine("- Group stories under their respective Features and Epics.");
            sb.AppendLine("- Bugs are also in scope and may not have a Feature.");
            sb.AppendLine("- For each story write a new summary in plain, non-technical language.");
            sb.AppendLine("- Do NOT copy or paraphrase the original description.");
            sb.AppendLine("- Use clear headings for each Epic, Feature, and Story.");
            sb.AppendLine("- Use bullet points or paragraphs for readability.");
        }
        else
        {
            sb.AppendLine(config.ReleaseNotesPrompt.Trim());
        }

        sb.AppendLine();
        sb.AppendLine("Work items:");

        sb.AppendLine(json);
        sb.AppendLine();
        sb.AppendLine($"After generating the notes, convert the content to {config.OutputFormat} format and include that version.");
        return sb.ToString();
    }

    protected override Task OnProjectChangedAsync()
    {
        return OnInitializedAsync();
    }

}
#endif
