@page "/projects/{ProjectName}/metrics-beta"
@using System.Text
@using System.Text.Json
@using System.Linq
@using DevOpsAssistant.Services
@using DevOpsAssistant.Services.Models
@using DevOpsAssistant.Utils
@using DevOpsAssistant.Components.Apex
@using ApexCharts
@using Mud = MudBlazor
@inject DevOpsApiService ApiService
@inject IJSRuntime JS
@inject PageStateService StateService
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<MetricsBeta> L
@inject ISnackbar Snackbar
@inherits ProjectComponentBase

<PageTitle>DevOpsAssistant - Metrics (beta)</PageTitle>

<MudText Typo="Typo.h4">@L["PageHeading"]</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error">@_error</MudAlert>
}

<MudPaper>
    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">@L["OptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudSelect T="string" @bind-Value="_path" Label="Backlog">
                @foreach (var b in _backlogs)
                {
                    <MudSelectItem Value="@b">@b</MudSelectItem>
                }
            </MudSelect>
            <MudSelect T="AggregateMode" @bind-Value="_mode" Label="Aggregate By">
                <MudSelectItem Value="AggregateMode.Week">Week</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Fortnight">Fortnight</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Month">Month</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Iteration">Iteration</MudSelectItem>
            </MudSelect>
            <MudDatePicker @bind-Date="_startDate" Label="Start Date"/>
            <MudDatePicker @bind-Date="_endDate" Label="End Date" MaxDate="@DateTime.Today"/>
            <MudTooltip Text='@L["VelocityTooltip"]'>
                <MudSelect T="VelocityMode" @bind-Value="_velocityMode" Label="Velocity By">
                    <MudSelectItem Value="VelocityMode.StoryPoints">Story Points</MudSelectItem>
                    <MudSelectItem Value="VelocityMode.OriginalEstimate">Original Estimate</MudSelectItem>
                </MudSelect>
            </MudTooltip>
        </MudStack>
        <MudText Typo="Typo.h6">@L["SprintEfficiencyOptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudAutocomplete T="string" Label="@L["NonSprintTag"]" @bind-Value="_tag" SearchFunc="SearchTags"/>
            <MudSwitch T="bool" @bind-Value="_tagMarksSprint" Label="@L["TagMarksSprint"]" Disabled="string.IsNullOrWhiteSpace(_tag)" Color="Mud.Color.Primary" />
            <MudSwitch T="bool" @bind-Value="_useSprintEfficiency" Label="@L["UseSprintEff"]" Disabled="string.IsNullOrWhiteSpace(_tag)" Color="Mud.Color.Primary" />
        </MudStack>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudButton Variant="Variant.Filled" Color="Mud.Color.Primary" OnClick="Load">Load</MudButton>
            <MudButton Variant="Variant.Outlined" OnClick="ExportCsv">Export CSV</MudButton>
        </MudStack>
    </MudStack>
</MudPaper>

@if (_loading)
{
    <MudProgressCircular Color="Mud.Color.Primary" Indeterminate="true"/>
}
else if (_periods.Any())
{
    <MudText Typo="Typo.h6" Class="mt-4">@L["TableHeading"]</MudText>
    <MudTable Items="_periods" Dense="true" Hover="true">
        <HeaderContent>
            <MudTh>Period Ending</MudTh>
            <MudTh>Avg Lead Time (days)</MudTh>
            <MudTh>Avg Cycle Time (days)</MudTh>
            <MudTh>Throughput</MudTh>
            <MudTh>Velocity</MudTh>
            <MudTh>@L["AvgWip"]</MudTh>
            <MudTh>@L["SprintEff"]</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Period">
                @(_mode == AggregateMode.Iteration ? context.Name : context.End.ToLocalDateString())
            </MudTd>
            <MudTd DataLabel="Lead">@context.AvgLeadTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Cycle">@context.AvgCycleTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Throughput">@context.Throughput</MudTd>
            <MudTd DataLabel="Velocity">@context.Velocity.ToString("0.0")</MudTd>
            <MudTd DataLabel="WIP">@context.AvgWip.ToString("0.0")</MudTd>
            <MudTd DataLabel="Sprint">@context.SprintEfficiency.ToString("0.0")</MudTd>
        </RowTemplate>
    </MudTable>
    <MudText Typo="Typo.h6" Class="mt-4">@L["ChartsHeading"]</MudText>

    <MudGrid>
        <MudItem xs="12" md="@(_leadCycleExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">Lead &amp; Cycle Time</MudText>
                    <MudIconButton Icon="@(_leadCycleExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleLeadCycle" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_leadCycleApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_leadCycleExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_barExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">Throughput &amp; Velocity</MudText>
                    <MudIconButton Icon="@(_barExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleBar" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Bar" Series="_barApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_barExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_wipExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["AvgWip"]</MudText>
                    <MudIconButton Icon="@(_wipExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleWip" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_wipApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_wipExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_sprintExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["SprintEff"]</MudText>
                    <MudIconButton Icon="@(_sprintExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleSprint" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_sprintApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_sprintExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_burnExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["BurnUp"]</MudText>
                    <MudIconButton Icon="@(_burnExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleBurn" />
                </MudStack>
                <MudButton OnClick="ToggleBurnChartControls"
                           EndIcon="@(_showBurnChartControls ? Icons.Material.Outlined.ArrowDropUp : Icons.Material.Outlined.ArrowDropDown)"
                           Class="mb-2">
                    @L["ProjectionOptions"]
                </MudButton>
                <MudCollapse Expanded="_showBurnChartControls">
                    <MudGrid Spacing="2">
                        <MudItem xs="12" md="6">
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                <MudNumericField T="double?" @bind-Value="_additionalPoints" Label="Additional Points"/>
                                <MudNumericField T="double?" @bind-Value="_efficiency" Label="Efficiency %"/>
                                <MudNumericField T="double?" @bind-Value="_errorRange" Label="Error %"/>
                                <MudButton Variant="Variant.Filled" Color="Mud.Color.Primary" OnClick="UpdateBurnUp">
                                    Update
                                </MudButton>
                            </MudStack>
                        </MudItem>
                        <MudItem xs="12" md="6">
                            @if (_daysMin.HasValue && _daysMax.HasValue)
                            {
                                <MudText Typo="Typo.subtitle1" Class="mt-2">
                                    @L["ProjectionHeading"]
                                </MudText>
                                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                    <MudTable Items="new[] { 0 }" Dense="true">
                                        <HeaderContent>
                                            <MudTh>@L["ProjectedDays"]</MudTh>
                                            <MudTh>@L["CompletionRange"]</MudTh>
                                        </HeaderContent>
                                        <RowTemplate>
                                            <MudTd>
                                                @(_daysMin == _daysMax
                                                    ? _daysMin.Value.ToString()
                                                    : $"{_daysMin}-{_daysMax}")
                                            </MudTd>
                                            <MudTd>
                                                @($"{_dateMin?.ToLocalDateString()} - {_dateMax?.ToLocalDateString()}")
                                            </MudTd>
                                        </RowTemplate>
                                    </MudTable>
                                </MudStack>
                            }
                        </MudItem>
                    </MudGrid>
                </MudCollapse>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_burnApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_burnExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_flowExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["Flow"]</MudText>
                    <MudIconButton Icon="@(_flowExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleFlow" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Area" Options="_flowOptions" Series="_flowApex" FormatYAxisLabel="FormatValue" Height="@ChartHeight(_flowExpanded)" />
            </MudPaper>
        </MudItem>
    </MudGrid>
    <MudButton Variant="Variant.Filled"
               Color="Mud.Color.Primary"
               StartIcon="@Icons.Material.Filled.ContentCopy"
               Disabled="_periods.Count == 0"
               OnClick="CopyPrompt">
        @L["GeneratePrompt"]
    </MudButton>
}

@code {
    [Parameter] public string ProjectName { get; set; } = string.Empty;
    private string _path = string.Empty;
    private string[] _backlogs = [];
    private bool _loading;
    private AggregateMode _mode = AggregateMode.Week;
    private VelocityMode _velocityMode = VelocityMode.StoryPoints;
    private DateTime? _startDate = DateTime.Today.AddDays(-84);
    private DateTime? _endDate = DateTime.Today;
    private List<PeriodMetrics> _periods = new();
    private List<IterationInfo> _iterations = new();
    private List<StoryMetric> _items = new();

    private double? _additionalPoints;
    private double? _efficiency;
    private double? _errorRange;
    private string _tag = string.Empty;
    private bool _tagMarksSprint;
    private bool _useSprintEfficiency;
    private List<string> _tags = new();
    private bool _showBurnChartControls;

    private RenderFragment BurnUpControls => @<>
                                             <MudButton OnClick="ToggleBurnChartControls"
                                                        EndIcon="@(_showBurnChartControls ? Icons.Material.Outlined.ArrowDropUp : Icons.Material.Outlined.ArrowDropDown)"
                                                        Class="mb-2">
                                                 @L["ProjectionOptions"]
                                             </MudButton>
                                             <MudCollapse Expanded="_showBurnChartControls">
                                                 <MudGrid Spacing="2">
                                                     <MudItem xs="12" md="6">
                                                         <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                                             <MudNumericField T="double?" @bind-Value="_additionalPoints" Label="Additional Points"/>
                                                             <MudNumericField T="double?" @bind-Value="_efficiency" Label="Efficiency %"/>
                                                             <MudNumericField T="double?" @bind-Value="_errorRange" Label="Error %"/>
                                                             <MudButton Variant="Variant.Filled" Color="Mud.Color.Primary" OnClick="UpdateBurnUp">Update</MudButton>
                                                         </MudStack>
                                                     </MudItem>
                                                     <MudItem xs="12" md="6">
                                                         @if (_daysMin.HasValue && _daysMax.HasValue)
                                                         {
                                                             <MudText Typo="Typo.subtitle1" Class="mt-2">
                                                                 @L["ProjectionHeading"]
                                                             </MudText>
                                                             <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                                                 <MudTable Items="new[] { 0 }" Dense="true">
                                                                     <HeaderContent>
                                                                         <MudTh>@L["ProjectedDays"]</MudTh>
                                                                         <MudTh>@L["CompletionRange"]</MudTh>
                                                                     </HeaderContent>
                                                                     <RowTemplate>
                                                                         <MudTd>
                                                                             @(_daysMin == _daysMax
                                                                                 ? _daysMin.Value.ToString()
                                                                                 : $"{_daysMin}-{_daysMax}")
                                                                         </MudTd>
                                                                         <MudTd>
                                                                             @($"{_dateMin?.ToLocalDateString()} - {_dateMax?.ToLocalDateString()}")
                                                                         </MudTd>
                                                                     </RowTemplate>
                                                                 </MudTable>
                                                             </MudStack>
                                                         }
                                                     </MudItem>
                                                 </MudGrid>
                                             </MudCollapse>
                                         </>;

    private string[] _xAxisLabels = [];
    private List<ChartSeries> _leadCycleSeries = [];
    private List<ChartSeries> _barSeries = [];
    private string[] _burnLabels = [];
    private string[] _flowLabels = [];
    private List<ChartSeries> _flowSeries = [];
    private List<ChartSeries> _wipSeries = [];
    private List<ChartSeries> _sprintSeries = [];

    private List<ApexSeries> _leadCycleApex = [];
    private List<ApexSeries> _barApex = [];
    private List<ApexSeries> _wipApex = [];
    private List<ApexSeries> _sprintApex = [];
    private List<ApexSeries> _burnApex = [];
    private List<ApexSeries> _flowApex = [];
    private ApexChartOptions<ChartPoint> _flowOptions = new() { Chart = new Chart { Stacked = true } };
    private bool _leadCycleExpanded;
    private bool _barExpanded;
    private bool _wipExpanded;
    private bool _sprintExpanded;
    private bool _burnExpanded;
    private bool _flowExpanded;
    private int? _daysMin;
    private int? _daysMax;
    private DateTime? _dateMin;
    private DateTime? _dateMax;


    private string? _error;
    private const string StateKey = "metrics";

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAsync();
        if (!string.IsNullOrWhiteSpace(ProjectName) &&
            ConfigService.CurrentProject.Name != ProjectName)
        {
            await ConfigService.SelectProjectAsync(ProjectName);
        }

        try
        {
            _backlogs = await ApiService.GetBacklogsAsync();
            if (_backlogs.Length > 0)
                _path = _backlogs[0];
            _tags = await ApiService.GetTagsAsync();

            var state = await StateService.LoadAsync<PageState>(StateKey);
            if (state != null)
            {
                if (!string.IsNullOrWhiteSpace(state.Path))
                    _path = state.Path;
                _mode = state.Mode;
                _velocityMode = state.VelocityMode;
                _startDate = state.StartDate;
                _endDate = state.EndDate ?? DateTime.Today;
                _additionalPoints = state.AdditionalPoints > 0 ? state.AdditionalPoints : null;
                _efficiency = state.Efficiency > 0 ? state.Efficiency : null;
                _errorRange = state.Error > 0 ? state.Error : null;
                _tag = state.Tag ?? string.Empty;
                _tagMarksSprint = state.TagMarksSprint;
                _useSprintEfficiency = state.UseSprintEfficiency;
            }

            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task Load()
    {
        _loading = true;
        StateHasChanged();
        try
        {
            var items = await ApiService.GetStoryMetricsAsync(_path, _startDate);
            var endDate = _endDate ?? DateTime.Today;
            _items = items.Where(i => i.ClosedDate.Date <= endDate).ToList();
            _iterations = _mode == AggregateMode.Iteration
                ? await ApiService.GetIterationsAsync()
                : [];
            ComputePeriods(_items, _iterations);
            ComputeBurnUp(_items);
            ComputeFlow(_items);
            await StateService.SaveAsync(StateKey, new PageState
            {
                Path = _path,
                Mode = _mode,
                VelocityMode = _velocityMode,
                StartDate = _startDate,
                EndDate = _endDate,
                AdditionalPoints = _additionalPoints ?? 0,
                Efficiency = _efficiency ?? 0,
                Error = _errorRange ?? 0,
                Tag = _tag,
                TagMarksSprint = _tagMarksSprint,
                UseSprintEfficiency = _useSprintEfficiency
            });
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private void ComputePeriods(List<StoryMetric> items, List<IterationInfo>? iterations = null)
    {
        _periods.Clear();
        _wipSeries.Clear();
        _sprintSeries.Clear();
        var startDate = _startDate ?? DateTime.Today.AddDays(-84);
        var endDate = _endDate ?? DateTime.Today;

        if (_mode == AggregateMode.Iteration && iterations != null)
        {
            foreach (var it in iterations.Where(i => i.EndDate >= startDate && i.EndDate <= endDate))
            {
                var rangeItems = items.Where(x => x.ClosedDate >= it.StartDate && x.ClosedDate <= it.EndDate && x.ClosedDate <= endDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Name = it.Name,
                    Start = it.StartDate,
                    End = it.EndDate,
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                }

                _periods.Add(metrics);
            }
        }
        else
        {
            DateTime start = _mode == AggregateMode.Month
                ? new DateTime(startDate.Year, startDate.Month, 1)
                : StartOfWeek(startDate);
            var endBoundary = endDate;
            while (start <= endBoundary)
            {
                DateTime next = _mode switch
                {
                    AggregateMode.Week => start.AddDays(7),
                    AggregateMode.Fortnight => start.AddDays(14),
                    _ => start.AddMonths(1)
                };
                var rangeItems = items.Where(x => x.ClosedDate >= start && x.ClosedDate < next && x.ClosedDate <= endDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Start = start,
                    End = next.AddDays(-1),
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                }

                _periods.Add(metrics);
                start = next;
            }
        }

        _xAxisLabels = _periods.Select(p => _mode == AggregateMode.Month
            ? p.End.ToString("yyyy-MM")
            : _mode == AggregateMode.Iteration
                ? p.Name
                : p.End.ToLocalDateString()).ToArray();
        var lead = _periods.Select(p => p.AvgLeadTime).ToArray();
        var cycle = _periods.Select(p => p.AvgCycleTime).ToArray();
        var throughput = _periods.Select(p => (double)p.Throughput).ToArray();
        var velocity = _periods.Select(p => p.Velocity).ToArray();
        _leadCycleSeries =
        [
            new ChartSeries { Name = "Lead Time", Data = lead },
            new ChartSeries { Name = "Cycle Time", Data = cycle }
        ];
        _barSeries =
        [
            new ChartSeries { Name = "Throughput", Data = throughput },
            new ChartSeries { Name = "Velocity", Data = velocity }
        ];
        var wip = _periods.Select(p => p.AvgWip).ToArray();
        _wipSeries = [new ChartSeries { Name = "Avg WIP", Data = wip }];
        if (!string.IsNullOrWhiteSpace(_tag))
        {
            var sprint = _periods.Select(p => p.SprintEfficiency).ToArray();
            _sprintSeries = [new ChartSeries { Name = "Sprint %", Data = sprint }];
        }

        _leadCycleApex = ToApexSeries(_leadCycleSeries, _xAxisLabels);
        _barApex = ToApexSeries(_barSeries, _xAxisLabels);
        _wipApex = ToApexSeries(_wipSeries, _xAxisLabels);
        _sprintApex = ToApexSeries(_sprintSeries, _xAxisLabels);
    }

    private void ComputeBurnUp(List<StoryMetric> items)
    {
        _burnApex.Clear();
        var efficiency = _useSprintEfficiency && !string.IsNullOrWhiteSpace(_tag)
            ? ComputeOverallSprintEfficiency(items)
            : _efficiency;
        if (items.Count == 0 || efficiency is null || _errorRange is null)
        {
            _burnLabels = [];
            return;
        }

        var start = items.Min(i => i.ClosedDate).Date;
        var end = _endDate ?? DateTime.Today;
        var daysActual = (end - start).Days + 1;
        double[] daily = new double[daysActual];
        foreach (var it in items)
        {
            if (it.ClosedDate.Date < start || it.ClosedDate.Date > end) continue;
            var idx = (it.ClosedDate.Date - start).Days;
            var val = _velocityMode == VelocityMode.StoryPoints ? it.StoryPoints : it.OriginalEstimate;
            daily[idx] += val;
        }

        double[] doneActual = new double[daysActual];
        double sum = 0;
        for (int i = 0; i < daysActual; i++)
        {
            sum += daily[i];
            doneActual[i] = sum;
        }

        var avgVel = sum / Math.Max(1, daysActual);
        var effVel = avgVel * (efficiency.Value / 100.0);
        var minVel = effVel * (1 - _errorRange.Value / 100.0);
        var maxVel = effVel * (1 + _errorRange.Value / 100.0);
        var finalTarget = sum + (_additionalPoints ?? 0);
        var remaining = Math.Max(0, finalTarget - sum);
        int daysMin = maxVel > 0 ? (int)Math.Ceiling(remaining / maxVel) : 0;
        int daysMax = minVel > 0 ? (int)Math.Ceiling(remaining / minVel) : 0;
        int projLen = daysActual + Math.Max(daysMin, daysMax);

        string[] labels = new string[projLen];
        List<ChartPoint> complete = new();
        List<ChartPoint> target = new();
        List<ChartPoint> minProj = new();
        List<ChartPoint> maxProj = new();

        for (int i = 0; i < projLen; i++)
        {
            var date = start.AddDays(i);
            labels[i] = date.ToLocalDateString();
            if (i < daysActual)
            {
                complete.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(doneActual[i], 2) });
                minProj.Add(new ChartPoint { Label = labels[i], Value = null });
                maxProj.Add(new ChartPoint { Label = labels[i], Value = null });
            }
            else
            {
                complete.Add(new ChartPoint { Label = labels[i], Value = null });
                var d = i - daysActual + 1;
                var minVal = Math.Min(sum + d * minVel, finalTarget);
                var maxVal = Math.Min(sum + d * maxVel, finalTarget);
                minProj.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(minVal, 2) });
                maxProj.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(maxVal, 2) });
            }
            target.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(finalTarget, 2) });
        }

        _burnLabels = labels;
        _burnApex = new List<ApexSeries>
        {
            new ApexSeries { Name = "Complete", Points = complete },
            new ApexSeries { Name = "Target", Points = target }
        };
        if (remaining > 0)
        {
            _burnApex.Add(new ApexSeries { Name = "Projection Min", Points = minProj });
            _burnApex.Add(new ApexSeries { Name = "Projection Max", Points = maxProj });
            _daysMin = daysMin;
            _daysMax = daysMax;
            _dateMin = end.AddDays(daysMin);
            _dateMax = end.AddDays(daysMax);
        }
        else
        {
            _daysMin = null;
            _daysMax = null;
            _dateMin = null;
            _dateMax = null;
        }
    }

    private void ComputeFlow(List<StoryMetric> items)
    {
        _flowSeries.Clear();
        if (items.Count == 0)
        {
            _flowLabels = [];
            return;
        }

        var start = items.Min(i => i.CreatedDate).Date;
        var end = items.Max(i => i.ClosedDate).Date;
        var days = (end - start).Days + 1;
        double[] backlog = new double[days];
        double[] wip = new double[days];
        double[] done = new double[days];
        for (int i = 0; i < days; i++)
        {
            var day = start.AddDays(i);
            backlog[i] = items.Count(it => it.CreatedDate.Date <= day && it.ActivatedDate.Date > day);
            wip[i] = items.Count(it => it.ActivatedDate.Date <= day && it.ClosedDate.Date > day);
            done[i] = items.Count(it => it.ClosedDate.Date <= day);
        }

        string[] labels = new string[days];
        for (int i = 0; i < days; i++)
        {
            labels[i] = start.AddDays(i).ToLocalDateString();
        }

        _flowLabels = labels;
        _flowSeries =
        [
            new ChartSeries { Name = "Backlog", Data = backlog },
            new ChartSeries { Name = "Work In Progress", Data = wip },
            new ChartSeries { Name = "Done", Data = done }
        ];

        _flowApex = ToApexSeries(_flowSeries, _flowLabels);
    }

    private double ComputeOverallSprintEfficiency(List<StoryMetric> items)
    {
        double total = items.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        double value = items.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
            .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        return total > 0
            ? _tagMarksSprint
                ? 100.0 * value / total
                : 100.0 * (total - value) / total
            : 0;
    }

    private static List<ApexSeries> ToApexSeries(List<ChartSeries> series, string[] labels)
    {
        var result = new List<ApexSeries>();
        foreach (var s in series)
        {
            var converted = new ApexSeries { Name = s.Name };
            for (int i = 0; i < s.Data.Length && i < labels.Length; i++)
            {
                var val = (decimal?)s.Data[i];
                if (val.HasValue)
                    val = Math.Round(val.Value, 2);
                converted.Points.Add(new ChartPoint { Label = labels[i], Value = val });
            }
            result.Add(converted);
        }
        return result;
    }

    private static string BuildCsv(IEnumerable<PeriodMetrics> periods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Period End,Avg Lead Time,Avg Cycle Time,Throughput,Velocity");
        foreach (var p in periods)
            sb.AppendLine($"{p.End:yyyy-MM-dd},{p.AvgLeadTime:0.0},{p.AvgCycleTime:0.0},{p.Throughput},{p.Velocity:0.0}");
        return sb.ToString();
    }

    private void ToggleBurnChartControls()
    {
        _showBurnChartControls = !_showBurnChartControls;
    }

    private static string BuildPrompt(IEnumerable<PeriodMetrics> periods, OutputFormat format)
    {
        var metrics = periods.Select(p => new
        {
            end = p.End.ToString("yyyy-MM-dd"),
            leadTime = p.AvgLeadTime,
            cycleTime = p.AvgCycleTime,
            throughput = p.Throughput,
            velocity = p.Velocity,
            avgWip = p.AvgWip,
            sprintEfficiency = p.SprintEfficiency
        });

        var summary = new
        {
            avgLeadTime = periods.Any() ? periods.Average(p => p.AvgLeadTime) : 0,
            avgCycleTime = periods.Any() ? periods.Average(p => p.AvgCycleTime) : 0,
            avgThroughput = periods.Any() ? periods.Average(p => p.Throughput) : 0,
            avgVelocity = periods.Any() ? periods.Average(p => p.Velocity) : 0,
            avgWip = periods.Any() ? periods.Average(p => p.AvgWip) : 0,
            avgSprintEfficiency = periods.Any() ? periods.Average(p => p.SprintEfficiency) : 0
        };

        var payload = new { metrics, summary };
        var json = JsonSerializer.Serialize(payload);

        var sb = new StringBuilder();
        sb.AppendLine("You are an experienced Agile Coach preparing a delivery metrics report for your Delivery Manager.");
        sb.AppendLine();
        sb.AppendLine("Your objective is to analyse team delivery data over time, identify trends or risks, and make useful, actionable recommendations based on standard Agile metrics. This report will help the Delivery Manager understand what’s working well, what might need investigation, and where to focus for continuous improvement.");
        sb.AppendLine();
        sb.AppendLine("You will use the following **markdown report template** to structure your output. Before generating the final report, feel free to ask any clarifying questions about the data or expectations to ensure a useful and accurate analysis.");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📊 Agile Delivery Metrics Report Template");
        sb.AppendLine();
        sb.AppendLine("```markdown");
        sb.AppendLine("# 📊 Agile Delivery Metrics Report");
        sb.AppendLine();
        sb.AppendLine("## 🗓️ Reporting Range");
        sb.AppendLine("> _From: [earliest date] To: [latest date]_");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📈 Summary Statistics");
        sb.AppendLine();
        sb.AppendLine("| Metric                | Average             |");
        sb.AppendLine("|-----------------------|---------------------|");
        sb.AppendLine("| Lead Time (days)      | {{avgLeadTime}} |");
        sb.AppendLine("| Cycle Time (days)     | {{avgCycleTime}} |");
        sb.AppendLine("| Throughput (items)    | {{avgThroughput}} |");
        sb.AppendLine("| Velocity (points)     | {{avgVelocity}} |");
        sb.AppendLine("| Avg WIP               | {{avgWip}} |");
        sb.AppendLine("| Sprint Efficiency (%) | {{avgSprintEfficiency}} |");
        sb.AppendLine();
        sb.AppendLine("> 📌 _Commentary: Summarise what these averages suggest about recent delivery performance._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📈 Trend Analysis");
        sb.AppendLine();
        sb.AppendLine("### Lead Time & Cycle Time");
        sb.AppendLine();
        sb.AppendLine("> _Analyse recent trends in lead time and cycle time. Are they improving, worsening, or volatile? What could be contributing to this?_");
        sb.AppendLine();
        sb.AppendLine("### Throughput & Velocity");
        sb.AppendLine();
        sb.AppendLine("> _Highlight any significant rises or drops. Are delivery patterns consistent or irregular? Note any anomalies or explanations._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🔄 Sprint Pattern Highlights");
        sb.AppendLine();
        sb.AppendLine("> _Pick out 3–5 noteworthy sprints (by end date) and describe what happened. Reference spikes, drops, or zero activity._");
        sb.AppendLine();
        sb.AppendLine("| Sprint End | Lead Time | Cycle Time | Throughput | Velocity | Avg WIP | Sprint % | Observations |");
        sb.AppendLine("|------------|-----------|------------|------------|----------|--------|----------|--------------|");
        sb.AppendLine("|            |           |            |            |          |        |          |              |");
        sb.AppendLine("|            |           |            |            |          |        |          |              |");
        sb.AppendLine("|            |           |            |            |          |        |          |              |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🚧 Risks & Bottlenecks");
        sb.AppendLine();
        sb.AppendLine("> _Identify any patterns suggesting risk (e.g. inconsistent throughput, stalled sprints, recurring zero velocities). Suggest what might be causing them._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## ✅ Recommendations");
        sb.AppendLine();
        sb.AppendLine("> _List 3–5 actionable insights the Delivery Manager can consider._");
        sb.AppendLine();
        sb.AppendLine("- [ ] Example: Investigate high cycle times around 2025-03-16 for potential process blockers.");
        sb.AppendLine("- [ ] Example: Monitor recent drop in velocity and validate sprint planning confidence.");
        sb.AppendLine("- [ ] Example: Encourage refinement practices to reduce lead time volatility.");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("_Compiled by:_ **Agile Coach Persona**  ");
        sb.AppendLine("_Report Date:_ **{{today}}**");
        sb.AppendLine("```");
        sb.AppendLine();
        sb.AppendLine($"Data: {json}");
        sb.AppendLine();
        if (format == OutputFormat.Inline)
            sb.AppendLine("Reply inline with the final report.");
        else
            sb.AppendLine($"Once you summarize the metrics, convert the output to {format} format and include it.");
        return sb.ToString();
    }

    private async Task ExportCsv()
    {
        if (_periods.Count == 0) return;
        var csv = BuildCsv(_periods);
        await JS.InvokeVoidAsync("downloadCsv", "metrics.csv", csv);
    }

    private async Task CopyPrompt()
    {
        if (_periods.Count == 0) return;
        var prompt = BuildPrompt(_periods, ConfigService.Config.OutputFormat);
        await JS.InvokeVoidAsync("copyText", prompt);
        Snackbar.Add(L["CopyToast"].Value, Severity.Success);
    }

    private string FormatValue(decimal value)
    {
        return value.ToString("0.##");
    }

    private async Task UpdateBurnUp()
    {
        if (_items.Count == 0) return;
        ComputeBurnUp(_items);
        await StateService.SaveAsync(StateKey, new PageState
        {
            Path = _path,
            Mode = _mode,
            VelocityMode = _velocityMode,
            StartDate = _startDate,
            AdditionalPoints = _additionalPoints ?? 0,
            Efficiency = _efficiency ?? 0,
            Error = _errorRange ?? 0,
            Tag = _tag,
            TagMarksSprint = _tagMarksSprint,
            UseSprintEfficiency = _useSprintEfficiency
        });
        StateHasChanged();
    }

    private void ToggleLeadCycle() => _leadCycleExpanded = !_leadCycleExpanded;
    private void ToggleBar() => _barExpanded = !_barExpanded;
    private void ToggleWip() => _wipExpanded = !_wipExpanded;
    private void ToggleSprint() => _sprintExpanded = !_sprintExpanded;
    private void ToggleBurn() => _burnExpanded = !_burnExpanded;
    private void ToggleFlow() => _flowExpanded = !_flowExpanded;

    private static int ChartHeight(bool expanded) => expanded ? 600 : 300;

    private Task<IEnumerable<string>> SearchTags(string value, CancellationToken _)
    {
        IEnumerable<string> result = _tags;
        if (!string.IsNullOrWhiteSpace(value))
            result = result.Where(t => t.Contains(value, StringComparison.OrdinalIgnoreCase));
        return Task.FromResult(result);
    }

    private static DateTime StartOfWeek(DateTime dt)
    {
        int diff = (7 + (int)dt.DayOfWeek - (int)DayOfWeek.Monday) % 7;
        return dt.Date.AddDays(-diff);
    }


    private class PeriodMetrics
    {
        public string Name { get; set; } = string.Empty;
        public DateTime Start { get; set; }
        public DateTime End { get; set; }
        public double AvgLeadTime { get; set; }
        public double AvgCycleTime { get; set; }
        public int Throughput { get; set; }
        public double Velocity { get; set; }
        public double AvgWip { get; set; }
        public double SprintEfficiency { get; set; }
    }

    private class PageState
    {
        public string Path { get; set; } = string.Empty;
        public AggregateMode Mode { get; set; }
        public VelocityMode VelocityMode { get; set; }
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }
        public double AdditionalPoints { get; set; }
        public double Efficiency { get; set; }
        public double Error { get; set; }
        public string? Tag { get; set; }
        public bool TagMarksSprint { get; set; }
        public bool UseSprintEfficiency { get; set; }
    }

    protected override Task OnProjectChangedAsync()
    {
        return OnInitializedAsync();
    }

}
