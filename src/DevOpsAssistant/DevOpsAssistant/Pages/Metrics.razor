@page "/projects/{ProjectName}/metrics"
@using System.Text
@using System.Text.Json
@using System.Linq
@using DevOpsAssistant.Services
@using DevOpsAssistant.Services.Models
@using DevOpsAssistant.Utils
@inject DevOpsApiService ApiService
@inject IJSRuntime JS
@inject PageStateService StateService
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<Metrics> L
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inherits ProjectComponentBase

<PageTitle>DevOpsAssistant - Metrics</PageTitle>

<MudText Typo="Typo.h4">@L["PageHeading"]</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error">@_error</MudAlert>
}

<MudPaper>
    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">@L["OptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudSelect T="string" @bind-Value="_path" Label="Backlog">
                @foreach (var b in _backlogs)
                {
                    <MudSelectItem Value="@b">@b</MudSelectItem>
                }
            </MudSelect>
            <MudSelect T="AggregateMode" @bind-Value="_mode" Label="Aggregate By">
                <MudSelectItem Value="AggregateMode.Week">Week</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Fortnight">Fortnight</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Month">Month</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Iteration">Iteration</MudSelectItem>
            </MudSelect>
            <MudDatePicker @bind-Date="_startDate" Label="Start Date"/>
            <MudTooltip Text='@L["VelocityTooltip"]'>
                <MudSelect T="VelocityMode" @bind-Value="_velocityMode" Label="Velocity By">
                    <MudSelectItem Value="VelocityMode.StoryPoints">Story Points</MudSelectItem>
                    <MudSelectItem Value="VelocityMode.OriginalEstimate">Original Estimate</MudSelectItem>
                </MudSelect>
            </MudTooltip>
            <MudAutocomplete T="string" Label="@L["NonSprintTag"]" @bind-Value="_tag" SearchFunc="SearchTags" />
            <MudSwitch T="bool" @bind-Value="_tagMarksSprint" Label="@L["TagMarksSprint"]" Disabled="string.IsNullOrWhiteSpace(_tag)" />
            <MudSwitch T="bool" @bind-Value="_useSprintEfficiency" Label="@L["UseSprintEff"]" Disabled="string.IsNullOrWhiteSpace(_tag)"/>
        </MudStack>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Load">Load</MudButton>
            <MudButton Variant="Variant.Outlined" OnClick="ExportCsv">Export CSV</MudButton>
            <MudButton Variant="Variant.Outlined" OnClick="Reset">Reset</MudButton>
        </MudStack>
    </MudStack>
</MudPaper>

@if (_loading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true"/>
}
else if (_periods.Any())
{
    <MudText Typo="Typo.h6" Class="mt-4">@L["TableHeading"]</MudText>
    <MudTable Items="_periods" Dense="true" Hover="true">
        <HeaderContent>
            <MudTh>Period Ending</MudTh>
            <MudTh>Avg Lead Time (days)</MudTh>
            <MudTh>Avg Cycle Time (days)</MudTh>
            <MudTh>Throughput</MudTh>
            <MudTh>Velocity</MudTh>
            <MudTh>@L["AvgWip"]</MudTh>
            <MudTh>@L["SprintEff"]</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Period">
                @(_mode == AggregateMode.Iteration ? context.Name : context.End.ToLocalDateString())
            </MudTd>
            <MudTd DataLabel="Lead">@context.AvgLeadTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Cycle">@context.AvgCycleTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Throughput">@context.Throughput</MudTd>
            <MudTd DataLabel="Velocity">@context.Velocity.ToString("0.0")</MudTd>
            <MudTd DataLabel="WIP">@context.AvgWip.ToString("0.0")</MudTd>
            <MudTd DataLabel="Sprint">@context.SprintEfficiency.ToString("0.0")</MudTd>
        </RowTemplate>
    </MudTable>
    <MudText Typo="Typo.h6" Class="mt-4">@L["ChartsHeading"]</MudText>

    <MudGrid>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">Lead &amp; Cycle Time</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowLeadCycleChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudChart ChartType="ChartType.Line"
                              ChartSeries="_leadCycleSeries"
                              XAxisLabels="_xAxisLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">Throughput &amp; Velocity</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowBarChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudChart ChartType="ChartType.Bar"
                              ChartSeries="_barSeries"
                              XAxisLabels="_xAxisLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">@L["AvgWip"]</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowWipChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudChart ChartType="ChartType.Line"
                              ChartSeries="_wipSeries"
                              XAxisLabels="_xAxisLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">@L["SprintEff"]</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowSprintChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudChart ChartType="ChartType.Line"
                              ChartSeries="_sprintSeries"
                              XAxisLabels="_xAxisLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudButton OnClick="ToggleBurnChartControls" EndIcon="@(_showBurnChartControls ? Icons.Material.Outlined.ArrowDropUp : Icons.Material.Outlined.ArrowDropDown)">@L["BurnUp"]</MudButton>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowBurnChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudCollapse Expanded="_showBurnChartControls">
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                            <MudNumericField T="double?" @bind-Value="_additionalPoints" Label="Additional Points"/>
                            <MudNumericField T="double?" @bind-Value="_efficiency" Label="Efficiency %"/>
                            <MudNumericField T="double?" @bind-Value="_errorRange" Label="Error %"/>
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="UpdateBurnUp">Update</MudButton>
                        </MudStack>
                        @if (_daysMin.HasValue && _daysMax.HasValue)
                        {
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                <MudText Typo="Typo.subtitle1" Class="mt-2">@L["ProjectionHeading"]</MudText>
                                <MudTable Items="new[] { 0 }" Dense="true">
                                    <HeaderContent>
                                        <MudTh>@L["ProjectedDays"]</MudTh>
                                        <MudTh>@L["CompletionRange"]</MudTh>
                                    </HeaderContent>
                                    <RowTemplate>
                                        <MudTd>@(_daysMin == _daysMax ? _daysMin!.Value.ToString() : $"{_daysMin}-{_daysMax}")</MudTd>
                                        <MudTd>@($"{_dateMin?.ToLocalDateString()} - {_dateMax?.ToLocalDateString()}")</MudTd>
                                    </RowTemplate>
                                </MudTable>
                            </MudStack>
                        }
                    </MudCollapse>
                    <MudChart ChartType="ChartType.Line"
                              ChartSeries="_burnSeries"
                              XAxisLabels="_burnLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-2" Style="height:100%">
                <MudStack Spacing="1">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">@L["Flow"]</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.OpenInFull" Size="Size.Small" OnClick="ShowFlowChart" title='@L["ExpandChart"]'/>
                    </MudStack>
                    <MudChart ChartType="ChartType.StackedBar"
                              ChartSeries="_flowSeries"
                              XAxisLabels="_flowLabels"
                              Class="responsive-chart"
                              Width="100%"
                              Height="100%"
                              AxisChartOptions="_axisOptions"/>
                </MudStack>
            </MudPaper>
        </MudItem>
    </MudGrid>
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Filled.ContentCopy"
               Disabled="_periods.Count == 0"
               OnClick="CopyPrompt">
        @L["GeneratePrompt"]
    </MudButton>
}

@code {
    [Parameter] public string ProjectName { get; set; } = string.Empty;
    private string _path = string.Empty;
    private string[] _backlogs = [];
    private bool _loading;
    private AggregateMode _mode = AggregateMode.Week;
    private VelocityMode _velocityMode = VelocityMode.StoryPoints;
    private DateTime? _startDate = DateTime.Today.AddDays(-84);
    private List<PeriodMetrics> _periods = new();
    private List<IterationInfo> _iterations = new();
    private List<StoryMetric> _items = new();

    private double? _additionalPoints;
    private double? _efficiency;
    private double? _errorRange;
    private string _tag = string.Empty;
    private bool _tagMarksSprint;
    private bool _useSprintEfficiency;
    private List<string> _tags = new();
    private bool _showBurnChartControls;

    private RenderFragment BurnUpControls => @<MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap" Style="margin-bottom:16px">
                                                 <MudNumericField T="double?" @bind-Value="_additionalPoints" Label="Additional Points"/>
                                                 <MudNumericField T="double?" @bind-Value="_efficiency" Label="Efficiency %"/>
                                                 <MudNumericField T="double?" @bind-Value="_errorRange" Label="Error %"/>
                                                 <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="UpdateBurnUp">Update</MudButton>
                                             </MudStack>;

    private string[] _xAxisLabels = [];
    private List<ChartSeries> _leadCycleSeries = [];
    private List<ChartSeries> _barSeries = [];
    private string[] _burnLabels = [];
    private List<ChartSeries> _burnSeries = [];
    private string[] _flowLabels = [];
    private List<ChartSeries> _flowSeries = [];
    private List<ChartSeries> _wipSeries = [];
    private List<ChartSeries> _sprintSeries = [];
    private int? _daysMin;
    private int? _daysMax;
    private DateTime? _dateMin;
    private DateTime? _dateMax;

    private AxisChartOptions _axisOptions = new()
    {
        MatchBoundsToSize = true,
        XAxisLabelRotation = 45
    };

    private string? _error;
    private const string StateKey = "metrics";

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAsync();
        if (!string.IsNullOrWhiteSpace(ProjectName) &&
            ConfigService.CurrentProject.Name != ProjectName)
        {
            await ConfigService.SelectProjectAsync(ProjectName);
        }

        try
        {
            _backlogs = await ApiService.GetBacklogsAsync();
            if (_backlogs.Length > 0)
                _path = _backlogs[0];
            _tags = await ApiService.GetTagsAsync();

            var state = await StateService.LoadAsync<PageState>(StateKey);
            if (state != null)
            {
                if (!string.IsNullOrWhiteSpace(state.Path))
                    _path = state.Path;
                _mode = state.Mode;
                _velocityMode = state.VelocityMode;
                _startDate = state.StartDate;
                _additionalPoints = state.AdditionalPoints > 0 ? state.AdditionalPoints : null;
                _efficiency = state.Efficiency > 0 ? state.Efficiency : null;
                _errorRange = state.Error > 0 ? state.Error : null;
                _tag = state.Tag ?? string.Empty;
                _tagMarksSprint = state.TagMarksSprint;
                _useSprintEfficiency = state.UseSprintEfficiency;
            }

            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task Load()
    {
        _loading = true;
        StateHasChanged();
        try
        {
            var items = await ApiService.GetStoryMetricsAsync(_path, _startDate);
            _items = items;
            _iterations = _mode == AggregateMode.Iteration
                ? await ApiService.GetIterationsAsync()
                : [];
            ComputePeriods(items, _iterations);
            ComputeBurnUp(items);
            ComputeFlow(items);
            await StateService.SaveAsync(StateKey, new PageState
            {
                Path = _path,
                Mode = _mode,
                VelocityMode = _velocityMode,
                StartDate = _startDate,
                AdditionalPoints = _additionalPoints ?? 0,
                Efficiency = _efficiency ?? 0,
                Error = _errorRange ?? 0,
                Tag = _tag,
                TagMarksSprint = _tagMarksSprint,
                UseSprintEfficiency = _useSprintEfficiency
            });
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private void ComputePeriods(List<StoryMetric> items, List<IterationInfo>? iterations = null)
    {
        _periods.Clear();
        _wipSeries.Clear();
        _sprintSeries.Clear();
        var startDate = _startDate ?? DateTime.Today.AddDays(-84);

        if (_mode == AggregateMode.Iteration && iterations != null)
        {
            foreach (var it in iterations.Where(i => i.EndDate >= startDate))
            {
                var rangeItems = items.Where(x => x.ClosedDate >= it.StartDate && x.ClosedDate <= it.EndDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Name = it.Name,
                    Start = it.StartDate,
                    End = it.EndDate,
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                }

                _periods.Add(metrics);
            }
        }
        else
        {
            DateTime start = _mode == AggregateMode.Month
                ? new DateTime(startDate.Year, startDate.Month, 1)
                : StartOfWeek(startDate);
            var endBoundary = DateTime.Today;
            while (start <= endBoundary)
            {
                DateTime next = _mode switch
                {
                    AggregateMode.Week => start.AddDays(7),
                    AggregateMode.Fortnight => start.AddDays(14),
                    _ => start.AddMonths(1)
                };
                var rangeItems = items.Where(x => x.ClosedDate >= start && x.ClosedDate < next).ToList();
                var metrics = new PeriodMetrics
                {
                    Start = start,
                    End = next.AddDays(-1),
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                }

                _periods.Add(metrics);
                start = next;
            }
        }

        _xAxisLabels = _periods.Select(p => _mode == AggregateMode.Month
            ? p.End.ToString("yyyy-MM")
            : _mode == AggregateMode.Iteration
                ? p.Name
                : p.End.ToLocalDateString()).ToArray();
        var lead = _periods.Select(p => p.AvgLeadTime).ToArray();
        var cycle = _periods.Select(p => p.AvgCycleTime).ToArray();
        var throughput = _periods.Select(p => (double)p.Throughput).ToArray();
        var velocity = _periods.Select(p => p.Velocity).ToArray();
        _leadCycleSeries =
        [
            new ChartSeries { Name = "Lead Time", Data = lead },
            new ChartSeries { Name = "Cycle Time", Data = cycle }
        ];
        _barSeries =
        [
            new ChartSeries { Name = "Throughput", Data = throughput },
            new ChartSeries { Name = "Velocity", Data = velocity }
        ];
        var wip = _periods.Select(p => p.AvgWip).ToArray();
        _wipSeries = [new ChartSeries { Name = "Avg WIP", Data = wip }];
        if (!string.IsNullOrWhiteSpace(_tag))
        {
            var sprint = _periods.Select(p => p.SprintEfficiency).ToArray();
            _sprintSeries = [new ChartSeries { Name = "Sprint %", Data = sprint }];
        }
    }

    private void ComputeBurnUp(List<StoryMetric> items)
    {
        _burnSeries.Clear();
        var efficiency = _useSprintEfficiency && !string.IsNullOrWhiteSpace(_tag)
            ? ComputeOverallSprintEfficiency(items)
            : _efficiency;
        if (items.Count == 0 || efficiency is null || _errorRange is null)
        {
            _burnLabels = [];
            return;
        }

        var start = items.Min(i => i.ClosedDate).Date;
        var end = DateTime.Today;
        var days = (end - start).Days + 1;
        double[] daily = new double[days];
        foreach (var it in items)
        {
            if (it.ClosedDate.Date < start || it.ClosedDate.Date > end) continue;
            var idx = (it.ClosedDate.Date - start).Days;
            var val = _velocityMode == VelocityMode.StoryPoints ? it.StoryPoints : it.OriginalEstimate;
            daily[idx] += val;
        }

        double[] done = new double[days];
        double sum = 0;
        for (int i = 0; i < days; i++)
        {
            sum += daily[i];
            done[i] = sum;
        }

        var avgVel = sum / Math.Max(1, days);
        var effVel = avgVel * (efficiency.Value / 100.0);
        var minVel = effVel * (1 - _errorRange.Value / 100.0);
        var maxVel = effVel * (1 + _errorRange.Value / 100.0);
        var finalTarget = sum + (_additionalPoints ?? 0);
        var remaining = Math.Max(0, finalTarget - sum);
        int daysMin = maxVel > 0 ? (int)Math.Ceiling(remaining / maxVel) : 0;
        int daysMax = minVel > 0 ? (int)Math.Ceiling(remaining / minVel) : 0;
        int projLen = days + Math.Max(daysMin, daysMax);
        Array.Resize(ref done, projLen);
        double[] target = Enumerable.Repeat(finalTarget, projLen).ToArray();
        double[] minProj = new double[projLen];
        double[] maxProj = new double[projLen];
        for (int i = days; i < projLen; i++)
        {
            var d = i - days + 1;
            minProj[i] = Math.Min(sum + d * minVel, finalTarget);
            maxProj[i] = Math.Min(sum + d * maxVel, finalTarget);
            done[i] = sum;
        }

        int step = Math.Max(1, (int)Math.Ceiling(projLen / 10.0));
        _burnLabels = Enumerable.Range(0, projLen)
            .Select(i => i % step == 0 ? start.AddDays(i).ToLocalDateString() : string.Empty)
            .ToArray();
        _burnSeries = new List<ChartSeries>
        {
            new ChartSeries { Name = "Complete", Data = done },
            new ChartSeries { Name = "Target", Data = target }
        };
        if (remaining > 0)
        {
            _burnSeries.Add(new ChartSeries { Name = "Projection Min", Data = minProj });
            _burnSeries.Add(new ChartSeries { Name = "Projection Max", Data = maxProj });
            _daysMin = daysMin;
            _daysMax = daysMax;
            _dateMin = end.AddDays(daysMin);
            _dateMax = end.AddDays(daysMax);
        }
        else
        {
            _daysMin = null;
            _daysMax = null;
            _dateMin = null;
            _dateMax = null;
        }
    }

    private void ComputeFlow(List<StoryMetric> items)
    {
        _flowSeries.Clear();
        if (items.Count == 0)
        {
            _flowLabels = [];
            return;
        }

        var start = items.Min(i => i.CreatedDate).Date;
        var end = items.Max(i => i.ClosedDate).Date;
        var days = (end - start).Days + 1;
        double[] backlog = new double[days];
        double[] wip = new double[days];
        double[] done = new double[days];
        for (int i = 0; i < days; i++)
        {
            var day = start.AddDays(i);
            backlog[i] = items.Count(it => it.CreatedDate.Date <= day && it.ActivatedDate.Date > day);
            wip[i] = items.Count(it => it.ActivatedDate.Date <= day && it.ClosedDate.Date > day);
            done[i] = items.Count(it => it.ClosedDate.Date <= day);
        }

        const int maxPoints = 30;
        int step = Math.Max(1, (int)Math.Ceiling(days / (double)maxPoints));
        int len = (int)Math.Ceiling(days / (double)step);
        double[] aggBacklog = new double[len];
        double[] aggWip = new double[len];
        double[] aggDone = new double[len];
        string[] labels = new string[len];
        for (int i = 0; i < len; i++)
        {
            int idx = Math.Min(days - 1, (i + 1) * step - 1);
            aggBacklog[i] = backlog[idx];
            aggWip[i] = wip[idx];
            aggDone[i] = done[idx];
            labels[i] = start.AddDays(idx).ToLocalDateString();
        }

        int labelStep = Math.Max(1, (int)Math.Ceiling(len / 10.0));
        for (int i = 0; i < len; i++)
        {
            if (i % labelStep != 0)
                labels[i] = string.Empty;
        }

        _flowLabels = labels;
        _flowSeries =
        [
            new ChartSeries { Name = "Backlog", Data = aggBacklog },
            new ChartSeries { Name = "Work In Progress", Data = aggWip },
            new ChartSeries { Name = "Done", Data = aggDone }
        ];
    }

    private double ComputeOverallSprintEfficiency(List<StoryMetric> items)
    {
        double total = items.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        double value = items.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
            .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        return total > 0
            ? _tagMarksSprint
                ? 100.0 * value / total
                : 100.0 * (total - value) / total
            : 0;
    }

    private static string BuildCsv(IEnumerable<PeriodMetrics> periods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Period End,Avg Lead Time,Avg Cycle Time,Throughput,Velocity");
        foreach (var p in periods)
            sb.AppendLine($"{p.End:yyyy-MM-dd},{p.AvgLeadTime:0.0},{p.AvgCycleTime:0.0},{p.Throughput},{p.Velocity:0.0}");
        return sb.ToString();
    }

    private void ToggleBurnChartControls()
    {
        _showBurnChartControls = !_showBurnChartControls;
    }

    private static string BuildPrompt(IEnumerable<PeriodMetrics> periods, OutputFormat format)
    {
        var metrics = periods.Select(p => new
        {
            end = p.End.ToString("yyyy-MM-dd"),
            leadTime = p.AvgLeadTime,
            cycleTime = p.AvgCycleTime,
            throughput = p.Throughput,
            velocity = p.Velocity
        });

        var summary = new
        {
            avgLeadTime = periods.Any() ? periods.Average(p => p.AvgLeadTime) : 0,
            avgCycleTime = periods.Any() ? periods.Average(p => p.AvgCycleTime) : 0,
            avgThroughput = periods.Any() ? periods.Average(p => p.Throughput) : 0,
            avgVelocity = periods.Any() ? periods.Average(p => p.Velocity) : 0
        };

        var payload = new { metrics, summary };
        var json = JsonSerializer.Serialize(payload);

        var sb = new StringBuilder();
        sb.AppendLine("You are an experienced Agile Coach preparing a delivery metrics report for your Delivery Manager.");
        sb.AppendLine();
        sb.AppendLine("Your objective is to analyse team delivery data over time, identify trends or risks, and make useful, actionable recommendations based on standard Agile metrics. This report will help the Delivery Manager understand what’s working well, what might need investigation, and where to focus for continuous improvement.");
        sb.AppendLine();
        sb.AppendLine("You will use the following **markdown report template** to structure your output. Before generating the final report, feel free to ask any clarifying questions about the data or expectations to ensure a useful and accurate analysis.");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📊 Agile Delivery Metrics Report Template");
        sb.AppendLine();
        sb.AppendLine("```markdown");
        sb.AppendLine("# 📊 Agile Delivery Metrics Report");
        sb.AppendLine();
        sb.AppendLine("## 🗓️ Reporting Range");
        sb.AppendLine("> _From: [earliest date] To: [latest date]_");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📈 Summary Statistics");
        sb.AppendLine();
        sb.AppendLine("| Metric              | Average     |");
        sb.AppendLine("|---------------------|-------------|");
        sb.AppendLine("| Lead Time (days)    | {{avgLeadTime}} |");
        sb.AppendLine("| Cycle Time (days)   | {{avgCycleTime}} |");
        sb.AppendLine("| Throughput (items)  | {{avgThroughput}} |");
        sb.AppendLine("| Velocity (points)   | {{avgVelocity}} |");
        sb.AppendLine();
        sb.AppendLine("> 📌 _Commentary: Summarise what these averages suggest about recent delivery performance._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 📈 Trend Analysis");
        sb.AppendLine();
        sb.AppendLine("### Lead Time & Cycle Time");
        sb.AppendLine();
        sb.AppendLine("> _Analyse recent trends in lead time and cycle time. Are they improving, worsening, or volatile? What could be contributing to this?_");
        sb.AppendLine();
        sb.AppendLine("### Throughput & Velocity");
        sb.AppendLine();
        sb.AppendLine("> _Highlight any significant rises or drops. Are delivery patterns consistent or irregular? Note any anomalies or explanations._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🔄 Sprint Pattern Highlights");
        sb.AppendLine();
        sb.AppendLine("> _Pick out 3–5 noteworthy sprints (by end date) and describe what happened. Reference spikes, drops, or zero activity._");
        sb.AppendLine();
        sb.AppendLine("| Sprint End | Lead Time | Cycle Time | Throughput | Velocity | Observations |");
        sb.AppendLine("|------------|-----------|------------|------------|----------|--------------|");
        sb.AppendLine("|            |           |            |            |          |              |");
        sb.AppendLine("|            |           |            |            |          |              |");
        sb.AppendLine("|            |           |            |            |          |              |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🚧 Risks & Bottlenecks");
        sb.AppendLine();
        sb.AppendLine("> _Identify any patterns suggesting risk (e.g. inconsistent throughput, stalled sprints, recurring zero velocities). Suggest what might be causing them._");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## ✅ Recommendations");
        sb.AppendLine();
        sb.AppendLine("> _List 3–5 actionable insights the Delivery Manager can consider._");
        sb.AppendLine();
        sb.AppendLine("- [ ] Example: Investigate high cycle times around 2025-03-16 for potential process blockers.");
        sb.AppendLine("- [ ] Example: Monitor recent drop in velocity and validate sprint planning confidence.");
        sb.AppendLine("- [ ] Example: Encourage refinement practices to reduce lead time volatility.");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("_Compiled by:_ **Agile Coach Persona**  ");
        sb.AppendLine("_Report Date:_ **{{today}}**");
        sb.AppendLine("```");
        sb.AppendLine();
        sb.AppendLine($"Data: {json}");
        sb.AppendLine();
        sb.AppendLine($"Once you summarize the metrics, convert the output to {format} format and include it.");
        return sb.ToString();
    }

    private async Task ExportCsv()
    {
        if (_periods.Count == 0) return;
        var csv = BuildCsv(_periods);
        await JS.InvokeVoidAsync("downloadCsv", "metrics.csv", csv);
    }

    private async Task CopyPrompt()
    {
        if (_periods.Count == 0) return;
        var prompt = BuildPrompt(_periods, ConfigService.Config.OutputFormat);
        await JS.InvokeVoidAsync("copyText", prompt);
        Snackbar.Add(L["CopyToast"].Value, Severity.Success);
    }

    private async Task UpdateBurnUp()
    {
        if (_items.Count == 0) return;
        ComputeBurnUp(_items);
        await StateService.SaveAsync(StateKey, new PageState
        {
            Path = _path,
            Mode = _mode,
            VelocityMode = _velocityMode,
            StartDate = _startDate,
            AdditionalPoints = _additionalPoints ?? 0,
            Efficiency = _efficiency ?? 0,
            Error = _errorRange ?? 0,
            Tag = _tag,
            TagMarksSprint = _tagMarksSprint,
            UseSprintEfficiency = _useSprintEfficiency
        });
        StateHasChanged();
    }

    private async Task Reset()
    {
        if (_backlogs.Length > 0)
            _path = _backlogs[0];
        _mode = AggregateMode.Week;
        _velocityMode = VelocityMode.StoryPoints;
        _startDate = DateTime.Today.AddDays(-84);
        _additionalPoints = null;
        _efficiency = null;
        _errorRange = null;
        _tag = string.Empty;
        _tagMarksSprint = false;
        _useSprintEfficiency = false;
        _periods.Clear();
        _iterations.Clear();
        _burnSeries.Clear();
        _wipSeries.Clear();
        _sprintSeries.Clear();
        _flowSeries.Clear();
        _daysMin = null;
        _daysMax = null;
        _dateMin = null;
        _dateMax = null;
        await StateService.ClearAsync(StateKey);
        StateHasChanged();
    }

    private Task<IEnumerable<string>> SearchTags(string value, CancellationToken _)
    {
        IEnumerable<string> result = _tags;
        if (!string.IsNullOrWhiteSpace(value))
            result = result.Where(t => t.Contains(value, StringComparison.OrdinalIgnoreCase));
        return Task.FromResult(result);
    }

    private static DateTime StartOfWeek(DateTime dt)
    {
        int diff = (7 + (int)dt.DayOfWeek - (int)DayOfWeek.Monday) % 7;
        return dt.Date.AddDays(-diff);
    }

    private async Task ShowLeadCycleChart() => await ShowChartDialog(ChartType.Line, _leadCycleSeries, _xAxisLabels, "Lead & Cycle Time");
    private async Task ShowBarChart() => await ShowChartDialog(ChartType.Bar, _barSeries, _xAxisLabels, "Throughput & Velocity");
    private async Task ShowWipChart() => await ShowChartDialog(ChartType.Line, _wipSeries, _xAxisLabels, "Avg WIP");
    private async Task ShowSprintChart() => await ShowChartDialog(ChartType.Line, _sprintSeries, _xAxisLabels, "Sprint Efficiency");
    private async Task ShowBurnChart() => await ShowChartDialog(ChartType.Line, _burnSeries, _burnLabels, L["BurnUp"], BurnUpControls);
    private async Task ShowFlowChart() => await ShowChartDialog(ChartType.StackedBar, _flowSeries, _flowLabels, L["Flow"]);

    private async Task ShowChartDialog(ChartType type, List<ChartSeries> series, string[] labels, string title, RenderFragment? controls = null)
    {
        var parameters = new DialogParameters
        {
            [nameof(ChartDialog.ChartType)] = type,
            [nameof(ChartDialog.ChartSeries)] = series,
            [nameof(ChartDialog.XAxisLabels)] = labels,
            [nameof(ChartDialog.AxisChartOptions)] = _axisOptions,
            [nameof(ChartDialog.Title)] = title,
            [nameof(ChartDialog.AdditionalControls)] = controls
        };
        await DialogService.ShowAsync<ChartDialog>(title, parameters, new DialogOptions { FullScreen = true });
    }

    private class PeriodMetrics
    {
        public string Name { get; set; } = string.Empty;
        public DateTime Start { get; set; }
        public DateTime End { get; set; }
        public double AvgLeadTime { get; set; }
        public double AvgCycleTime { get; set; }
        public int Throughput { get; set; }
        public double Velocity { get; set; }
        public double AvgWip { get; set; }
        public double SprintEfficiency { get; set; }
    }

    private class PageState
    {
        public string Path { get; set; } = string.Empty;
        public AggregateMode Mode { get; set; }
        public VelocityMode VelocityMode { get; set; }
        public DateTime? StartDate { get; set; }
        public double AdditionalPoints { get; set; }
        public double Efficiency { get; set; }
        public double Error { get; set; }
        public string? Tag { get; set; }
        public bool TagMarksSprint { get; set; }
        public bool UseSprintEfficiency { get; set; }
    }

    protected override Task OnProjectChangedAsync()
    {
        return OnInitializedAsync();
    }

}