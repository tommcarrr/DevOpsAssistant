@page "/projects/{ProjectName}/metrics"
@using System.Text
@using System.Text.Json
@using System.Linq
@using System.Globalization
@using System.Resources
@using GeneratedPrompts
@using DevOpsAssistant.Services.Models
@using DevOpsAssistant.Components.Apex
@using ApexCharts
@using Mud = MudBlazor
@inject DevOpsApiService ApiService
@inject IJSRuntime JS
@inject PageStateService StateService
@inject PromptService PromptService
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<Metrics> L
@inject ISnackbar Snackbar
@inherits ProjectComponentBase

<PageTitle>@L["PageTitle"]</PageTitle>

<MudText Typo="Typo.h4">@L["PageHeading"]</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error">@_error</MudAlert>
/*end*/}

<MudPaper>
    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">@L["OptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudSelect T="string" @bind-Value="_path" Label="@L["Backlog"]">
                @foreach (var b in _backlogs)
                {
                    <MudSelectItem Value="@b">@b</MudSelectItem>
                /*end*/}
            </MudSelect>
            <MudDatePicker @bind-Date="_startDate" Label="@L["StartDate"]"/>
            <MudDatePicker @bind-Date="_endDate" Label="@L["EndDate"]" MaxDate="@DateTime.Today"/>
            </MudStack>
            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudSelect T="AggregateMode" @bind-Value="_mode" Label="@L["AggregateBy"]">
                <MudSelectItem Value="AggregateMode.Week">@L["AggregateWeek"]</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Fortnight">@L["AggregateFortnight"]</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Month">@L["AggregateMonth"]</MudSelectItem>
                <MudSelectItem Value="AggregateMode.Iteration">@L["AggregateIteration"]</MudSelectItem>
            </MudSelect>
            <MudTooltip Text='@L["VelocityTooltip"]'>
                <MudSelect T="VelocityMode" @bind-Value="_velocityMode" Label="@L["VelocityBy"]">
                    <MudSelectItem Value="VelocityMode.StoryPoints">@L["VelocityStoryPoints"]</MudSelectItem>
                    <MudSelectItem Value="VelocityMode.OriginalEstimate">@L["VelocityOriginalEstimate"]</MudSelectItem>
                </MudSelect>
            </MudTooltip>
        </MudStack>
        <MudText Typo="Typo.h6">@L["SprintEfficiencyOptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudAutocomplete T="string" Label="@L["NonSprintTag"]" @bind-Value="_tag" SearchFunc="SearchTags"/>
            <MudSwitch T="bool" @bind-Value="_tagMarksSprint" Label="@L["TagMarksSprint"]" Disabled="string.IsNullOrWhiteSpace(_tag)" Color="Mud.Color.Primary" />
            <MudSwitch T="bool" @bind-Value="_useSprintEfficiency" Label="@L["UseSprintEff"]" Disabled="string.IsNullOrWhiteSpace(_tag)" Color="Mud.Color.Primary" />
        </MudStack>
        <MudText Typo="Typo.h6">@L["IgnoreTagsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudAutocomplete T="string" Label="@L["NonSprintTag"]" @bind-Value="_ignoreTag" SearchFunc="SearchIgnoreTags" />
            <MudButton Variant="Variant.Text" OnClick="AddIgnoreTag" Disabled="string.IsNullOrWhiteSpace(_ignoreTag)">@L["AddTag"]</MudButton>
        </MudStack>
        @if (_ignoredTags.Any())
        {
            <MudChipSet T="string" Class="mb-2">
                @foreach (var t in _ignoredTags)
                {
                    <MudChip Value="@t" OnClose="(MudChip<string> _) => RemoveIgnoreTag(t)">@t</MudChip>
                /*end*/}
            </MudChipSet>
        /*end*/}
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudButton Variant="Variant.Filled" Color="Mud.Color.Primary" OnClick="Load">@L["Load"]</MudButton>
            <MudButton Variant="Variant.Outlined" OnClick="ExportCsv">@L["ExportCsv"]</MudButton>
        </MudStack>
    </MudStack>
</MudPaper>

@if (_loading)
{
    <MudProgressCircular Color="Mud.Color.Primary" Indeterminate="true"/>
/*end*/}
else if (_periods.Any())
{
    <MudText Typo="Typo.h6" Class="mt-4">@L["TableHeading"]</MudText>
    <MudTable Items="_periods" Dense="true" Hover="true">
        <HeaderContent>
            <MudTh>@L["PeriodEnding"]</MudTh>
            <MudTh>@L["AvgLeadTimeDays"]</MudTh>
            <MudTh>@L["AvgCycleTimeDays"]</MudTh>
            <MudTh>@L["Throughput"]</MudTh>
            <MudTh>@L["Velocity"]</MudTh>
            <MudTh>@L["AvgWip"]</MudTh>
            <MudTh>@L["SprintEff"]</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="@L["Period"]">
                @(_mode == AggregateMode.Iteration ? context.Name : context.End.ToLocalDateString())
            </MudTd>
            <MudTd DataLabel="@L["Lead"]">@context.AvgLeadTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="@L["Cycle"]">@context.AvgCycleTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="@L["Throughput"]">@context.Throughput</MudTd>
            <MudTd DataLabel="@L["Velocity"]">@context.Velocity.ToString("0.0")</MudTd>
            <MudTd DataLabel="@L["Wip"]">@context.AvgWip.ToString("0.0")</MudTd>
            <MudTd DataLabel="@L["Sprint"]">@context.SprintEfficiency.ToString("0.0")</MudTd>
        </RowTemplate>
    </MudTable>
    <MudText Typo="Typo.h6" Class="mt-4">@L["ChartsHeading"]</MudText>

    <MudGrid>
        <MudItem xs="12" md="@(_leadCycleExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["LeadCycleTitle"]</MudText>
                    <MudIconButton Icon="@(_leadCycleExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleLeadCycle"
                                   title="@(_leadCycleExpanded ? L["CollapseChart"] : L["ExpandChart"])" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_leadCycleApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_leadCycleExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_barExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["ThroughputVelocityTitle"]</MudText>
                    <MudIconButton Icon="@(_barExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleBar"
                                   title="@(_barExpanded ? L["CollapseChart"] : L["ExpandChart"])" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Bar" Series="_barApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_barExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_wipExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["AvgWip"]</MudText>
                    <MudIconButton Icon="@(_wipExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleWip"
                                   title="@(_wipExpanded ? L["CollapseChart"] : L["ExpandChart"])" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_wipApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_wipExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_sprintExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["SprintEff"]</MudText>
                    <MudIconButton Icon="@(_sprintExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleSprint"
                                   title="@(_sprintExpanded ? L["CollapseChart"] : L["ExpandChart"])" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Line" Series="_sprintApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_sprintExpanded)" />
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_burnExpanded ? 12 : 6)">
            <MudPaper Class="pa-6" Style="overflow:visible">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["BurnUp"]</MudText>
                    <MudIconButton Icon="@(_burnExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleBurn"
                                   title="@(_burnExpanded ? L["CollapseChart"] : L["ExpandChart"])" />
                </MudStack>
                <SimpleApexChart @key="_burnApex" SeriesType="SeriesType.Line" Options="_burnOptions" Series="_burnApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_burnExpanded)" />
                <MudButton OnClick="ToggleBurnChartControls"
                           EndIcon="@(_showBurnChartControls ? Icons.Material.Outlined.ArrowDropUp : Icons.Material.Outlined.ArrowDropDown)"
                           Class="mb-2">
                    @L["ProjectionOptions"]
                </MudButton>
                <MudCollapse Expanded="_showBurnChartControls">
                    <MudGrid Spacing="2">
                        <MudItem xs="12" md="6">
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                <MudNumericField T="double?" @bind-Value="_additionalPoints" Label="@L["AdditionalPoints"]" Immediate="true" />
                                <MudNumericField T="double?" @bind-Value="_efficiency" Label="@L["EfficiencyPercent"]" Immediate="true" />
                                <MudNumericField T="double?" @bind-Value="_errorRange" Label="@L["ErrorPercent"]" Immediate="true" />
                                <MudButton Variant="Variant.Filled" Color="Mud.Color.Primary" OnClick="UpdateBurnUp">
                                    @L["Update"]
                                </MudButton>
                            </MudStack>
                        </MudItem>
                        <MudItem xs="12" md="6">
                            @if (_daysMin.HasValue && _daysMax.HasValue)
                            {
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
                                <MudTable Items="[0]" Dense="true">
                                    <HeaderContent>
                                        <MudTh>@L["ProjectedDays"]</MudTh>
                                        <MudTh>@L["CompletionRange"]</MudTh>
                                    </HeaderContent>
                                    <RowTemplate>
                                        <MudTd>
                                            @(_daysMin == _daysMax
                                            ? _daysMin.Value.ToString()
                                            : $"{_daysMin}-{_daysMax}")
                                        </MudTd>
                                        <MudTd>
                                            @($"{_dateMin?.ToLocalDateString()} - {_dateMax?.ToLocalDateString()}")
                                        </MudTd>
                                    </RowTemplate>
                                </MudTable>
                            </MudStack>
                            /*end*/}
                        </MudItem>
                    </MudGrid>
                </MudCollapse>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="@(_flowExpanded ? 12 : 6)">
            <MudPaper Class="pa-6">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">@L["Flow"]</MudText>
                    <MudIconButton Icon="@(_flowExpanded ? Icons.Material.Filled.CloseFullscreen : Icons.Material.Filled.OpenInFull)"
                                   Size="Mud.Size.Small" OnClick="ToggleFlow" />
                </MudStack>
                <SimpleApexChart SeriesType="SeriesType.Area" Options="_flowOptions" Series="_flowApex" FormatYAxisLabel="FormatValue" Class="@ChartClass(_flowExpanded)" />
            </MudPaper>
        </MudItem>
    </MudGrid>
    <MudButton Variant="Variant.Filled"
               Color="Mud.Color.Primary"
               StartIcon="@Icons.Material.Filled.ContentCopy"
               Disabled="_periods.Count == 0"
               OnClick="CopyPrompt">
        @L["GeneratePrompt"]
    </MudButton>
/*end*/}

@code {
    [Parameter] public string ProjectName { get; set; } = string.Empty;
    private string _path = string.Empty;
    private string[] _backlogs = [];
    private bool _loading;
    private AggregateMode _mode = AggregateMode.Week;
    private VelocityMode _velocityMode = VelocityMode.StoryPoints;
    private DateTime? _startDate = DateTime.Today.AddDays(-84);
    private DateTime? _endDate = DateTime.Today;
    private readonly List<PeriodMetrics> _periods = new();
    private List<IterationInfo> _iterations = new();
    private List<StoryMetric> _items = new();

    private double? _additionalPoints;
    private double? _efficiency;
    private double? _errorRange;
    private string _tag = string.Empty;
    private bool _tagMarksSprint;
    private bool _useSprintEfficiency;
    private HashSet<string> _ignoredTags = new();
    private string _ignoreTag = string.Empty;
    private List<string> _tags = [];
    private bool _showBurnChartControls;

    private string[] _xAxisLabels = [];
    private List<ChartSeries> _leadCycleSeries = [];
    private List<ChartSeries> _barSeries = [];
    private string[] _flowLabels = [];
    private string[] _burnLabels = [];
    private List<ChartSeries> _flowSeries = [];
    private List<ChartSeries> _wipSeries = [];
    private List<ChartSeries> _sprintSeries = [];

    private List<ApexSeries> _leadCycleApex = [];
    private List<ApexSeries> _barApex = [];
    private List<ApexSeries> _wipApex = [];
    private List<ApexSeries> _sprintApex = [];
    private List<ApexSeries> _burnApex = [];
    private List<ApexSeries> _flowApex = [];
    private ApexChartOptions<ChartPoint> _burnOptions = new();
    private readonly ApexChartOptions<ChartPoint> _flowOptions = new() { Chart = new Chart { Stacked = true } };
    private bool _leadCycleExpanded;
    private bool _barExpanded;
    private bool _wipExpanded;
    private bool _sprintExpanded;
    private bool _burnExpanded;
    private bool _flowExpanded;
    private int? _daysMin;
    private int? _daysMax;
    private DateTime? _dateMin;
    private DateTime? _dateMax;


    private string? _error;
    private const string StateKey = "metrics";

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAsync();
        if (!string.IsNullOrWhiteSpace(ProjectName) &&
            ConfigService.CurrentProject.Name != ProjectName)
        {
            await ConfigService.SelectProjectAsync(ProjectName);
        /*end*/}

        try
        {
            _backlogs = await ApiService.GetBacklogsAsync();
            if (_backlogs.Length > 0)
                _path = _backlogs[0];
            _tags = await ApiService.GetTagsAsync();

            _ignoredTags.Clear();

            var state = await StateService.LoadAsync<PageState>(StateKey);
            if (state != null)
            {
                if (!string.IsNullOrWhiteSpace(state.Path))
                    _path = state.Path;
                _mode = state.Mode;
                _velocityMode = state.VelocityMode;
                _startDate = state.StartDate;
                _endDate = state.EndDate ?? DateTime.Today;
                _additionalPoints = state.AdditionalPoints > 0 ? state.AdditionalPoints : null;
                _efficiency = state.Efficiency > 0 ? state.Efficiency : null;
                _errorRange = state.Error > 0 ? state.Error : null;
                _tag = state.Tag ?? string.Empty;
                _tagMarksSprint = state.TagMarksSprint;
                _useSprintEfficiency = state.UseSprintEfficiency;
                if (state.IgnoredTags != null)
                    foreach (var t in state.IgnoredTags)
                        _ignoredTags.Add(t);
            /*end*/}

            _error = null;
        /*end*/}
        catch (Exception ex)
        {
            _error = ex.Message;
        /*end*/}
    /*end*/}

    private async Task Load()
    {
        _loading = true;
        StateHasChanged();
        try
        {
            var items = await ApiService.GetStoryMetricsAsync(_path, _startDate);
            var endDate = _endDate ?? DateTime.Today;
            _items = FilterItems(items)
                .Where(i => i.ClosedDate.Date <= endDate)
                .ToList();
            _iterations = _mode == AggregateMode.Iteration
                ? await ApiService.GetIterationsAsync()
                : [];
            ComputePeriods(_items, _iterations);
            ComputeBurnUp(_items);
            ComputeFlow(_items);
            await StateService.SaveAsync(StateKey, new PageState
            {
                Path = _path,
                Mode = _mode,
                VelocityMode = _velocityMode,
                StartDate = _startDate,
                EndDate = _endDate,
                AdditionalPoints = _additionalPoints ?? 0,
                Efficiency = _efficiency ?? 0,
                Error = _errorRange ?? 0,
                Tag = _tag,
                TagMarksSprint = _tagMarksSprint,
                UseSprintEfficiency = _useSprintEfficiency,
                IgnoredTags = _ignoredTags.ToList()
            /*end*/});
            _error = null;
        /*end*/}
        catch (Exception ex)
        {
            _error = ex.Message;
        /*end*/}
        finally
        {
            _loading = false;
        /*end*/}
    /*end*/}

    private void ComputePeriods(List<StoryMetric> items, List<IterationInfo>? iterations = null)
    {
        _periods.Clear();
        _wipSeries.Clear();
        _sprintSeries.Clear();
        var startDate = _startDate ?? DateTime.Today.AddDays(-84);
        var endDate = _endDate ?? DateTime.Today;

        if (_mode == AggregateMode.Iteration && iterations != null)
        {
            foreach (var it in iterations.Where(i => i.EndDate >= startDate && i.EndDate <= endDate))
            {
                var rangeItems = items.Where(x => x.ClosedDate >= it.StartDate && x.ClosedDate <= it.EndDate && x.ClosedDate <= endDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Name = it.Name,
                    Start = it.StartDate,
                    End = it.EndDate,
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                /*end*/};
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                /*end*/}

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                /*end*/}

                _periods.Add(metrics);
            /*end*/}
        /*end*/}
        else
        {
            DateTime start = _mode == AggregateMode.Month
                ? new DateTime(startDate.Year, startDate.Month, 1)
                : StartOfWeek(startDate);
            var endBoundary = endDate;
            while (start <= endBoundary)
            {
                DateTime next = _mode switch
                {
                    AggregateMode.Week => start.AddDays(7),
                    AggregateMode.Fortnight => start.AddDays(14),
                    _ => start.AddMonths(1)
                /*end*/};
                var rangeItems = items.Where(x => x.ClosedDate >= start && x.ClosedDate < next && x.ClosedDate <= endDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Start = start,
                    End = next.AddDays(-1),
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                /*end*/};
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                /*end*/}

                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                if (!string.IsNullOrWhiteSpace(_tag))
                {
                    var value = rangeItems.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
                        .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
                    metrics.SprintEfficiency = metrics.Velocity > 0
                        ? _tagMarksSprint
                            ? 100.0 * value / metrics.Velocity
                            : 100.0 * (metrics.Velocity - value) / metrics.Velocity
                        : 0;
                /*end*/}

                _periods.Add(metrics);
                start = next;
            /*end*/}
        /*end*/}

        _xAxisLabels = _periods.Select(p => _mode == AggregateMode.Month
            ? p.End.ToString("yyyy-MM")
            : _mode == AggregateMode.Iteration
                ? p.Name
                : p.End.ToLocalDateString()).ToArray();
        var lead = _periods.Select(p => p.AvgLeadTime).ToArray();
        var cycle = _periods.Select(p => p.AvgCycleTime).ToArray();
        var throughput = _periods.Select(p => (double)p.Throughput).ToArray();
        var velocity = _periods.Select(p => p.Velocity).ToArray();
        _leadCycleSeries =
        [
            new ChartSeries { Name = "Lead Time", Data = lead },
            new ChartSeries { Name = "Cycle Time", Data = cycle }
        ];
        _barSeries =
        [
            new ChartSeries { Name = "Throughput", Data = throughput },
            new ChartSeries { Name = "Velocity", Data = velocity }
        ];
        var wip = _periods.Select(p => p.AvgWip).ToArray();
        _wipSeries = [new ChartSeries { Name = "Avg WIP", Data = wip }];
        if (!string.IsNullOrWhiteSpace(_tag))
        {
            var sprint = _periods.Select(p => p.SprintEfficiency).ToArray();
            _sprintSeries = [new ChartSeries { Name = "Sprint %", Data = sprint }];
        /*end*/}

        _leadCycleApex = ToApexSeries(_leadCycleSeries, _xAxisLabels);
        _barApex = ToApexSeries(_barSeries, _xAxisLabels);
        _wipApex = ToApexSeries(_wipSeries, _xAxisLabels);
        _sprintApex = ToApexSeries(_sprintSeries, _xAxisLabels);
    /*end*/}

    private void ComputeBurnUp(List<StoryMetric> items)
    {
        _burnApex.Clear();
        if (items.Count == 0)
        {
            _burnLabels = [];
            return;
        /*end*/}
        var efficiency = _useSprintEfficiency && !string.IsNullOrWhiteSpace(_tag)
            ? ComputeOverallSprintEfficiency(items)
            : _efficiency;

        var start = (_startDate ?? items.Min(i => i.ClosedDate)).Date;
        var end = _endDate ?? DateTime.Today;
        var daysActual = (end - start).Days + 1;
        double[] daily = new double[daysActual];
        foreach (var it in items)
        {
            if (it.ClosedDate.Date < start || it.ClosedDate.Date > end) continue;
            var idx = (it.ClosedDate.Date - start).Days;
            var val = _velocityMode == VelocityMode.StoryPoints ? it.StoryPoints : it.OriginalEstimate;
            daily[idx] += val;
        /*end*/}

        double[] doneActual = new double[daysActual];
        double sum = 0;
        for (int i = 0; i < daysActual; i++)
        {
            sum += daily[i];
            doneActual[i] = sum;
        /*end*/}

        var avgVel = sum / Math.Max(1, daysActual);
        var effVel = avgVel * (efficiency.GetValueOrDefault() / 100.0);
        var minVel = effVel * (1 - (_errorRange ?? 0) / 100.0);
        var maxVel = effVel * (1 + (_errorRange ?? 0) / 100.0);
        var finalTarget = sum + (_additionalPoints ?? 0);
        var remaining = Math.Max(0, finalTarget - sum);
        int daysMin = maxVel > 0 ? (int)Math.Ceiling(remaining / maxVel) : 0;
        int daysMax = minVel > 0 ? (int)Math.Ceiling(remaining / minVel) : 0;
        int projLen = daysActual + Math.Max(daysMin, daysMax);

        string[] labels = new string[projLen];
        _burnLabels = labels;
        List<ChartPoint> complete = new();
        List<ChartPoint> target = new();
        List<ChartPoint> trend = new();
        List<ChartPoint> minProj = new();
        List<ChartPoint> maxProj = new();

        bool maxReached = false;
        for (int i = 0; i < projLen; i++)
        {
            var date = start.AddDays(i);
            labels[i] = date.ToLocalDateString();
            if (i < daysActual)
            {
                complete.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(doneActual[i], 2) });
                minProj.Add(new ChartPoint { Label = labels[i], Value = null });
                maxProj.Add(new ChartPoint { Label = labels[i], Value = null });
            /*end*/}
            else
            {
                complete.Add(new ChartPoint { Label = labels[i], Value = null });
                var d = i - daysActual + 1;
                var minVal = Math.Min(sum + d * minVel, finalTarget);
                var maxVal = sum + d * maxVel;
                minProj.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(minVal, 2) });
                if (!maxReached)
                {
                    if (maxVal >= finalTarget)
                    {
                        maxProj.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(finalTarget, 2) });
                        maxReached = true;
                    /*end*/}
                    else
                    {
                        maxProj.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(maxVal, 2) });
                    /*end*/}
                /*end*/}
                else
                {
                    maxProj.Add(new ChartPoint { Label = labels[i], Value = null });
                /*end*/}
            /*end*/}
            target.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(finalTarget, 2) });
        /*end*/}

        // Straight trend line from 0 to final completion
        double slope = daysActual > 1 ? sum / (daysActual - 1) : 0;
        for (int i = 0; i < projLen; i++)
        {
            if (i < daysActual)
            {
                var val = slope * i;
                trend.Add(new ChartPoint { Label = labels[i], Value = (decimal)Math.Round(val, 2) });
            /*end*/}
            else
            {
                trend.Add(new ChartPoint { Label = labels[i], Value = null });
            /*end*/}
        /*end*/}

        _burnApex = [
            new ApexSeries { Name = "Complete", Points = complete },
            new ApexSeries { Name = "Trend", Points = trend },
            new ApexSeries { Name = "Target", Points = target }
        ];
        if (remaining > 0)
        {
            _burnApex.Add(new ApexSeries { Name = "Projection Min", Points = minProj });
            _burnApex.Add(new ApexSeries { Name = "Projection Max", Points = maxProj });
            _daysMin = daysMin;
            _daysMax = daysMax;
            _dateMin = end.AddDays(daysMin);
            _dateMax = end.AddDays(daysMax);
        /*end*/}
        else
        {
            _daysMin = null;
            _daysMax = null;
            _dateMin = null;
            _dateMax = null;
        /*end*/}

        List<double> dash = [];
        foreach (var s in _burnApex)
        {
            dash.Add(s.Name is "Trend" or "Projection Min" or "Projection Max" ? 5d : 0d);
        /*end*/}
        _burnOptions.Stroke = new Stroke { DashArray = new ApexCharts.Size(dash) };
    /*end*/}

    private void ComputeFlow(List<StoryMetric> items)
    {
        _flowSeries.Clear();
        if (items.Count == 0)
        {
            _flowLabels = [];
            return;
        /*end*/}

        var start = (_startDate ?? items.Min(i => i.CreatedDate)).Date;
        var end = (_endDate ?? items.Max(i => i.ClosedDate)).Date;
        var days = (end - start).Days + 1;
        double[] backlog = new double[days];
        double[] wip = new double[days];
        double[] done = new double[days];
        for (int i = 0; i < days; i++)
        {
            var day = start.AddDays(i);
            backlog[i] = items.Count(it => it.CreatedDate.Date <= day && it.ActivatedDate.Date > day);
            wip[i] = items.Count(it => it.ActivatedDate.Date <= day && it.ClosedDate.Date > day);
            done[i] = items.Count(it => it.ClosedDate.Date <= day);
        /*end*/}

        string[] labels = new string[days];
        for (int i = 0; i < days; i++)
        {
            labels[i] = start.AddDays(i).ToLocalDateString();
        /*end*/}

        _flowLabels = labels;
        _flowSeries =
        [
            new ChartSeries { Name = "Backlog", Data = backlog },
            new ChartSeries { Name = "Work In Progress", Data = wip },
            new ChartSeries { Name = "Done", Data = done }
        ];

        _flowApex = ToApexSeries(_flowSeries, _flowLabels);
    /*end*/}

    private double ComputeOverallSprintEfficiency(List<StoryMetric> items)
    {
        double total = items.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        double value = items.Where(w => w.Tags.Any(t => t.Equals(_tag, StringComparison.OrdinalIgnoreCase)))
            .Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate);
        return total > 0
            ? _tagMarksSprint
                ? 100.0 * value / total
                : 100.0 * (total - value) / total
            : 0;
    /*end*/}

    private static List<ApexSeries> ToApexSeries(List<ChartSeries> series, string[] labels)
    {
        List<ApexSeries> result = [];
        foreach (var s in series)
        {
            var converted = new ApexSeries { Name = s.Name };
            for (int i = 0; i < s.Data.Length && i < labels.Length; i++)
            {
                var val = (decimal?)s.Data[i];
                if (val.HasValue)
                    val = Math.Round(val.Value, 2);
                converted.Points.Add(new ChartPoint { Label = labels[i], Value = val });
            /*end*/}
            result.Add(converted);
        /*end*/}
        return result;
    /*end*/}

    private static string BuildCsv(IEnumerable<PeriodMetrics> periods)
    {
        var sb = new StringBuilder();
        var rm = new ResourceManager("DevOpsAssistant.Pages.Metrics", typeof(Metrics).Assembly);
        sb.AppendLine(rm.GetString("CsvHeader") ?? "CsvHeader");
        foreach (var p in periods)
            sb.AppendLine($"{p.End:yyyy-MM-dd},{p.AvgLeadTime:0.0},{p.AvgCycleTime:0.0},{p.Throughput},{p.Velocity:0.0}");
        return sb.ToString();
    /*end*/}

    private static string BuildPromptData(IEnumerable<PeriodMetrics> periods)
    {
        var list = periods.ToList();
        var metrics = list.Select(p => new
        {
            end = p.End.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture),
            leadTime = p.AvgLeadTime,
            cycleTime = p.AvgCycleTime,
            throughput = p.Throughput,
            velocity = p.Velocity,
            avgWip = p.AvgWip,
            sprintEfficiency = p.SprintEfficiency
        /*end*/});
        decimal totalLead = 0;
        decimal totalCycle = 0;
        decimal totalThroughput = 0;
        decimal totalVelocity = 0;
        decimal totalWip = 0;
        decimal totalSprint = 0;
        int count = 0;

        foreach (var p in list)
        {
            totalLead += (decimal)p.AvgLeadTime;
            totalCycle += (decimal)p.AvgCycleTime;
            totalThroughput += p.Throughput;
            totalVelocity += (decimal)p.Velocity;
            totalWip += (decimal)p.AvgWip;
            totalSprint += (decimal)p.SprintEfficiency;
            count++;
        /*end*/}

        var summary = new
        {
            avgLeadTime = count > 0 ? totalLead / count : 0,
            avgCycleTime = count > 0 ? totalCycle / count : 0,
            avgThroughput = count > 0 ? totalThroughput / count : 0,
            avgVelocity = count > 0 ? totalVelocity / count : 0,
            avgWip = count > 0 ? totalWip / count : 0,
            avgSprintEfficiency = count > 0 ? totalSprint / count : 0
        /*end*/};
        var payload = new { metrics, summary };
        return JsonSerializer.Serialize(payload);
    /*end*/}

    private void ToggleBurnChartControls()
    {
        _showBurnChartControls = !_showBurnChartControls;
    /*end*/}


    private async Task ExportCsv()
    {
        if (_periods.Count == 0) return;
        var csv = BuildCsv(_periods);
        await JS.InvokeVoidAsync("downloadCsv", "metrics.csv", csv);
    /*end*/}

    private async Task CopyPrompt()
    {
        if (_periods.Count == 0) return;
        var json = BuildPromptData(_periods);
        var prompt = PromptService.BuildMetricsPrompt(json, ConfigService.Config.OutputFormat);
        await JS.InvokeVoidAsync("copyText", prompt);
        Snackbar.Add(L["CopyToast"].Value, Severity.Success);
    /*end*/}

    private string FormatValue(decimal value)
    {
        return value.ToString("0.##");
    /*end*/}

    private async Task UpdateBurnUp()
    {
        if (_items.Count == 0) return;
        ComputeBurnUp(_items);
        await StateService.SaveAsync(StateKey, new PageState
        {
            Path = _path,
            Mode = _mode,
            VelocityMode = _velocityMode,
            StartDate = _startDate,
            AdditionalPoints = _additionalPoints ?? 0,
            Efficiency = _efficiency ?? 0,
            Error = _errorRange ?? 0,
            Tag = _tag,
            TagMarksSprint = _tagMarksSprint,
            UseSprintEfficiency = _useSprintEfficiency,
            IgnoredTags = _ignoredTags.ToList()
        /*end*/});
        StateHasChanged();
    /*end*/}

    private void ToggleLeadCycle() => _leadCycleExpanded = !_leadCycleExpanded;
    private void ToggleBar() => _barExpanded = !_barExpanded;
    private void ToggleWip() => _wipExpanded = !_wipExpanded;
    private void ToggleSprint() => _sprintExpanded = !_sprintExpanded;
    private void ToggleBurn() => _burnExpanded = !_burnExpanded;
    private void ToggleFlow() => _flowExpanded = !_flowExpanded;

    private static int ChartHeight(bool expanded) => expanded ? 800 : 300;

    private static string ChartClass(bool expanded) =>
        expanded ? "responsive-chart expanded-chart" : "responsive-chart";

    private Task<IEnumerable<string>> SearchTags(string value, CancellationToken _)
    {
        IEnumerable<string> result = _tags;
        if (!string.IsNullOrWhiteSpace(value))
            result = result.Where(t => t.Contains(value, StringComparison.OrdinalIgnoreCase));
        return Task.FromResult(result);
    /*end*/}

    private Task<IEnumerable<string>> SearchIgnoreTags(string value, CancellationToken _)
    {
        IEnumerable<string> result = _tags;
        if (!string.IsNullOrWhiteSpace(value))
            result = result.Where(t => t.Contains(value, StringComparison.OrdinalIgnoreCase));
        result = result.Where(t => !_ignoredTags.Contains(t));
        return Task.FromResult(result);
    /*end*/}

    private IEnumerable<StoryMetric> FilterItems(IEnumerable<StoryMetric> items)
    {
        if (_ignoredTags.Count == 0)
            return items;
        return items.Where(i => !i.Tags.Any(t => _ignoredTags.Contains(t)));
    /*end*/}

    private void AddIgnoreTag()
    {
        if (string.IsNullOrWhiteSpace(_ignoreTag))
            return;
        _ignoredTags.Add(_ignoreTag);
        _ignoreTag = string.Empty;
    /*end*/}

    private void RemoveIgnoreTag(string tag)
    {
        _ignoredTags.Remove(tag);
    /*end*/}

    private static DateTime StartOfWeek(DateTime dt)
    {
        int diff = (7 + (int)dt.DayOfWeek - (int)DayOfWeek.Monday) % 7;
        return dt.Date.AddDays(-diff);
    /*end*/}



    private class PageState
    {
        public string Path { get; set; } = string.Empty;
        public AggregateMode Mode { get; set; }
        public VelocityMode VelocityMode { get; set; }
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }
        public double AdditionalPoints { get; set; }
        public double Efficiency { get; set; }
        public double Error { get; set; }
        public string? Tag { get; set; }
        public bool TagMarksSprint { get; set; }
        public bool UseSprintEfficiency { get; set; }
        public List<string>? IgnoredTags { get; set; }
    /*end*/}

    protected override Task OnProjectChangedAsync()
    {
        return OnInitializedAsync();
    /*end*/}

/*end*/}
