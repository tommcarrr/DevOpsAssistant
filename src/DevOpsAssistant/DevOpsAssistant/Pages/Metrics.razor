@page "/projects/{ProjectName}/metrics"
@using System.Text
@using System.Linq
@using DevOpsAssistant.Services
@using DevOpsAssistant.Services.Models
@using DevOpsAssistant.Utils
@inject DevOpsApiService ApiService
@inject IJSRuntime JS
@inject PageStateService StateService
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<Metrics> L
@inject ISnackbar Snackbar
@inherits ProjectComponentBase

<PageTitle>DevOpsAssistant - Metrics</PageTitle>

<MudText Typo="Typo.h4">@L["PageHeading"]</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error">@_error</MudAlert>
}

<MudPaper>
    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">@L["OptionsHeading"]</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End" Wrap="Wrap.Wrap">
            <MudSelect T="string" @bind-Value="_path" Label="Backlog">
                @foreach (var b in _backlogs)
                {
                    <MudSelectItem Value="@b">@b</MudSelectItem>
                }
        </MudSelect>
        <MudSelect T="AggregateMode" @bind-Value="_mode" Label="Aggregate By">
            <MudSelectItem Value="AggregateMode.Week">Week</MudSelectItem>
            <MudSelectItem Value="AggregateMode.Fortnight">Fortnight</MudSelectItem>
            <MudSelectItem Value="AggregateMode.Month">Month</MudSelectItem>
            <MudSelectItem Value="AggregateMode.Iteration">Iteration</MudSelectItem>
        </MudSelect>
        <MudDatePicker @bind-Date="_startDate" Label="Start Date" />
        <MudTooltip Text='@L["VelocityTooltip"]'>
            <MudSelect T="VelocityMode" @bind-Value="_velocityMode" Label="Velocity By">
                <MudSelectItem Value="VelocityMode.StoryPoints">Story Points</MudSelectItem>
                <MudSelectItem Value="VelocityMode.OriginalEstimate">Original Estimate</MudSelectItem>
            </MudSelect>
        </MudTooltip>
        <MudNumericField T="double" @bind-Value="_targetPoints" Label="Total Points" />
        <MudNumericField T="double" @bind-Value="_efficiency" Label="Efficiency %" />
        <MudNumericField T="double" @bind-Value="_errorRange" Label="Error %" />
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Load">Load</MudButton>
        <MudButton Variant="Variant.Outlined" OnClick="ExportCsv">Export CSV</MudButton>
        <MudButton Variant="Variant.Outlined" OnClick="Reset">Reset</MudButton>
        </MudStack>
    </MudStack>
</MudPaper>

@if (_loading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
} else if (_periods.Any()) {
    <MudText Typo="Typo.h6" Class="mt-4">@L["TableHeading"]</MudText>
    <MudTable Items="_periods" Dense="true" Hover="true">
        <HeaderContent>
            <MudTh>Period Ending</MudTh>
            <MudTh>Avg Lead Time (days)</MudTh>
            <MudTh>Avg Cycle Time (days)</MudTh>
            <MudTh>Throughput</MudTh>
            <MudTh>Velocity</MudTh>
            <MudTh>@L["AvgWip"]</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Period">
                @(_mode == AggregateMode.Iteration ? context.Name : context.End.ToLocalDateString())
            </MudTd>
            <MudTd DataLabel="Lead">@context.AvgLeadTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Cycle">@context.AvgCycleTime.ToString("0.0")</MudTd>
            <MudTd DataLabel="Throughput">@context.Throughput</MudTd>
            <MudTd DataLabel="Velocity">@context.Velocity.ToString("0.0")</MudTd>
            <MudTd DataLabel="WIP">@context.AvgWip.ToString("0.0")</MudTd>
        </RowTemplate>
    </MudTable>
    <MudText Typo="Typo.h6" Class="mt-4">@L["ChartsHeading"]</MudText>

    <MudPaper Class="pa-2">
        <MudChart ChartType="ChartType.Line"
                  ChartSeries="_leadCycleSeries"
                  XAxisLabels="_xAxisLabels"
                  Class="responsive-chart"
                  Width="100%"
                  Height="100%"
                  AxisChartOptions="_axisOptions" />
    </MudPaper>
    <MudPaper Class="pa-2">
        <MudChart ChartType="ChartType.Bar"
                  ChartSeries="_barSeries"
                  XAxisLabels="_xAxisLabels"
                  Class="responsive-chart"
                  Width="100%"
                  Height="100%"
                  AxisChartOptions="_axisOptions" />
    </MudPaper>
    <MudText Typo="Typo.h6" Class="mt-4">@L["BurnUp"]</MudText>
    <MudPaper Class="pa-2">
        <MudChart ChartType="ChartType.Line"
                  ChartSeries="_burnSeries"
                  XAxisLabels="_burnLabels"
                  Class="responsive-chart"
                  Width="100%"
                  Height="100%"
                  AxisChartOptions="_axisOptions" />
    </MudPaper>
    <MudText Typo="Typo.h6" Class="mt-4">@L["Flow"]</MudText>
    <MudPaper Class="pa-2">
        <MudChart ChartType="ChartType.Line"
                  ChartSeries="_flowSeries"
                  XAxisLabels="_flowLabels"
                  Class="responsive-chart"
                  Width="100%"
                  Height="100%"
                  AxisChartOptions="_axisOptions" />
    </MudPaper>
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Filled.ContentCopy"
               Disabled="_periods.Count == 0"
               OnClick="CopyPrompt">@L["GeneratePrompt"]</MudButton>
}

@code {
    [Parameter] public string ProjectName { get; set; } = string.Empty;
    private string _path = string.Empty;
    private string[] _backlogs = [];
    private bool _loading;
    private AggregateMode _mode = AggregateMode.Week;
    private VelocityMode _velocityMode = VelocityMode.StoryPoints;
    private DateTime? _startDate = DateTime.Today.AddDays(-84);
    private List<PeriodMetrics> _periods = new();
    private List<IterationInfo> _iterations = new();
    private List<StoryMetric> _items = new();

    private double _targetPoints = 100;
    private double _efficiency = 80;
    private double _errorRange = 10;

    private string[] _xAxisLabels = [];
    private List<ChartSeries> _leadCycleSeries = [];
    private List<ChartSeries> _barSeries = [];
    private string[] _burnLabels = [];
    private List<ChartSeries> _burnSeries = [];
    private string[] _flowLabels = [];
    private List<ChartSeries> _flowSeries = [];
    private AxisChartOptions _axisOptions = new()
    {
        MatchBoundsToSize = true,
        XAxisLabelRotation = 45
    };
    private string? _error;
    private const string StateKey = "metrics";

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAsync();
        if (!string.IsNullOrWhiteSpace(ProjectName) &&
            ConfigService.CurrentProject.Name != ProjectName)
        {
            await ConfigService.SelectProjectAsync(ProjectName);
        }
        try
        {
            _backlogs = await ApiService.GetBacklogsAsync();
            if (_backlogs.Length > 0)
                _path = _backlogs[0];

            var state = await StateService.LoadAsync<PageState>(StateKey);
            if (state != null)
            {
                if (!string.IsNullOrWhiteSpace(state.Path))
                    _path = state.Path;
                _mode = state.Mode;
                _velocityMode = state.VelocityMode;
                _startDate = state.StartDate;
                _targetPoints = state.TargetPoints > 0 ? state.TargetPoints : _targetPoints;
                _efficiency = state.Efficiency > 0 ? state.Efficiency : _efficiency;
                _errorRange = state.Error > 0 ? state.Error : _errorRange;
            }

            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task Load()
    {
        _loading = true;
        StateHasChanged();
        try
        {
            var items = await ApiService.GetStoryMetricsAsync(_path, _startDate);
            _items = items;
            _iterations = _mode == AggregateMode.Iteration
                ? await ApiService.GetIterationsAsync()
                : [];
            ComputePeriods(items, _iterations);
            ComputeBurnUp(items);
            ComputeFlow(items);
            await StateService.SaveAsync(StateKey, new PageState
            {
                Path = _path,
                Mode = _mode,
                VelocityMode = _velocityMode,
                StartDate = _startDate,
                TargetPoints = _targetPoints,
                Efficiency = _efficiency,
                Error = _errorRange
            });
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private void ComputePeriods(List<StoryMetric> items, List<IterationInfo>? iterations = null)
    {
        _periods.Clear();
        var startDate = _startDate ?? DateTime.Today.AddDays(-84);

        if (_mode == AggregateMode.Iteration && iterations != null)
        {
            foreach (var it in iterations.Where(i => i.EndDate >= startDate))
            {
                var rangeItems = items.Where(x => x.ClosedDate >= it.StartDate && x.ClosedDate <= it.EndDate).ToList();
                var metrics = new PeriodMetrics
                {
                    Name = it.Name,
                    Start = it.StartDate,
                    End = it.EndDate,
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }
                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                _periods.Add(metrics);
            }
        }
        else
        {
            DateTime start = _mode == AggregateMode.Month
                ? new DateTime(startDate.Year, startDate.Month, 1)
                : StartOfWeek(startDate);
            var endBoundary = DateTime.Today;
            while (start <= endBoundary)
            {
                DateTime next = _mode switch
                {
                    AggregateMode.Week => start.AddDays(7),
                    AggregateMode.Fortnight => start.AddDays(14),
                    _ => start.AddMonths(1)
                };
                var rangeItems = items.Where(x => x.ClosedDate >= start && x.ClosedDate < next).ToList();
                var metrics = new PeriodMetrics
                {
                    Start = start,
                    End = next.AddDays(-1),
                    Throughput = rangeItems.Count,
                    AvgLeadTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.CreatedDate).TotalDays) : 0,
                    AvgCycleTime = rangeItems.Any() ? rangeItems.Average(w => (w.ClosedDate - w.ActivatedDate).TotalDays) : 0,
                    Velocity = rangeItems.Sum(w => _velocityMode == VelocityMode.StoryPoints ? w.StoryPoints : w.OriginalEstimate)
                };
                var overlap = items.Where(w => w.ActivatedDate <= metrics.End && w.ClosedDate >= metrics.Start);
                double active = 0;
                foreach (var w in overlap)
                {
                    var s = w.ActivatedDate > metrics.Start ? w.ActivatedDate.Date : metrics.Start.Date;
                    var e = w.ClosedDate < metrics.End ? w.ClosedDate.Date : metrics.End.Date;
                    active += (e - s).TotalDays + 1;
                }
                var days = (metrics.End.Date - metrics.Start.Date).TotalDays + 1;
                metrics.AvgWip = days > 0 ? active / days : 0;
                _periods.Add(metrics);
                start = next;
            }
        }

        _xAxisLabels = _periods.Select(p => _mode == AggregateMode.Month
                ? p.End.ToString("yyyy-MM")
                : _mode == AggregateMode.Iteration ? p.Name : p.End.ToLocalDateString()).ToArray();
        var lead = _periods.Select(p => p.AvgLeadTime).ToArray();
        var cycle = _periods.Select(p => p.AvgCycleTime).ToArray();
        var throughput = _periods.Select(p => (double)p.Throughput).ToArray();
        var velocity = _periods.Select(p => p.Velocity).ToArray();
        _leadCycleSeries =
        [
            new ChartSeries { Name = "Lead Time", Data = lead },
            new ChartSeries { Name = "Cycle Time", Data = cycle }
        ];
        _barSeries =
        [
            new ChartSeries { Name = "Throughput", Data = throughput },
            new ChartSeries { Name = "Velocity", Data = velocity }
        ];
    }

    private void ComputeBurnUp(List<StoryMetric> items)
    {
        _burnSeries.Clear();
        if (items.Count == 0) { _burnLabels = []; return; }

        var start = items.Min(i => i.ClosedDate).Date;
        var end = items.Max(i => i.ClosedDate).Date;
        var days = (end - start).Days + 1;
        double[] daily = new double[days];
        foreach (var it in items)
        {
            var idx = (it.ClosedDate.Date - start).Days;
            var val = _velocityMode == VelocityMode.StoryPoints ? it.StoryPoints : it.OriginalEstimate;
            daily[idx] += val;
        }
        double[] done = new double[days];
        double sum = 0;
        for (int i = 0; i < days; i++)
        {
            sum += daily[i];
            done[i] = sum;
        }
        var avgVel = sum / Math.Max(1, days);
        var effVel = avgVel * (_efficiency / 100.0);
        var minVel = effVel * (1 - _errorRange / 100.0);
        var maxVel = effVel * (1 + _errorRange / 100.0);
        var remaining = Math.Max(0, _targetPoints - sum);
        int daysMin = minVel > 0 ? (int)Math.Ceiling(remaining / maxVel) : 0;
        int daysMax = maxVel > 0 ? (int)Math.Ceiling(remaining / minVel) : 0;
        int projLen = days + Math.Max(daysMin, daysMax);
        Array.Resize(ref done, projLen);
        double[] target = Enumerable.Repeat(_targetPoints, projLen).ToArray();
        double[] minProj = new double[projLen];
        double[] maxProj = new double[projLen];
        for (int i = days; i < projLen; i++)
        {
            var d = i - days + 1;
            minProj[i] = Math.Min(sum + d * minVel, _targetPoints);
            maxProj[i] = Math.Min(sum + d * maxVel, _targetPoints);
            done[i] = sum; // extend actual line
        }
        _burnLabels = Enumerable.Range(0, projLen).Select(i => start.AddDays(i).ToLocalDateString()).ToArray();
        _burnSeries =
        [
            new ChartSeries { Name = "Complete", Data = done },
            new ChartSeries { Name = "Projection Min", Data = minProj },
            new ChartSeries { Name = "Projection Max", Data = maxProj },
            new ChartSeries { Name = "Target", Data = target }
        ];
    }

    private void ComputeFlow(List<StoryMetric> items)
    {
        _flowSeries.Clear();
        if (items.Count == 0) { _flowLabels = []; return; }

        var start = items.Min(i => i.CreatedDate).Date;
        var end = items.Max(i => i.ClosedDate).Date;
        var days = (end - start).Days + 1;
        double[] backlog = new double[days];
        double[] wip = new double[days];
        double[] done = new double[days];
        for (int i = 0; i < days; i++)
        {
            var day = start.AddDays(i);
            backlog[i] = items.Count(it => it.CreatedDate.Date <= day && it.ActivatedDate.Date > day);
            wip[i] = items.Count(it => it.ActivatedDate.Date <= day && it.ClosedDate.Date > day);
            done[i] = items.Count(it => it.ClosedDate.Date <= day);
        }
        _flowLabels = Enumerable.Range(0, days).Select(i => start.AddDays(i).ToLocalDateString()).ToArray();
        _flowSeries =
        [
            new ChartSeries { Name = "Backlog", Data = backlog },
            new ChartSeries { Name = "Work In Progress", Data = wip },
            new ChartSeries { Name = "Done", Data = done }
        ];
    }

    private static string BuildCsv(IEnumerable<PeriodMetrics> periods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Period End,Avg Lead Time,Avg Cycle Time,Throughput,Velocity");
        foreach (var p in periods)
            sb.AppendLine($"{p.End:yyyy-MM-dd},{p.AvgLeadTime:0.0},{p.AvgCycleTime:0.0},{p.Throughput},{p.Velocity:0.0}");
        return sb.ToString();
    }

    private static string BuildPrompt(IEnumerable<PeriodMetrics> periods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("You are an Agile Coach preparing a delivery metrics report for your Delivery Manager.");
        sb.AppendLine("Highlight any trends or issues based on the data below.");
        sb.AppendLine();
        sb.AppendLine("Period End,Avg Lead Time,Avg Cycle Time,Throughput,Velocity");
        foreach (var p in periods)
            sb.AppendLine($"{p.End:yyyy-MM-dd},{p.AvgLeadTime:0.0},{p.AvgCycleTime:0.0},{p.Throughput},{p.Velocity:0.0}");
        return sb.ToString();
    }

    private async Task ExportCsv()
    {
        if (_periods.Count == 0) return;
        var csv = BuildCsv(_periods);
        await JS.InvokeVoidAsync("downloadCsv", "metrics.csv", csv);
    }

    private async Task CopyPrompt()
    {
        if (_periods.Count == 0) return;
        var prompt = BuildPrompt(_periods);
        await JS.InvokeVoidAsync("copyText", prompt);
        Snackbar.Add(L["CopyToast"].Value, Severity.Success);
    }

    private async Task Reset()
    {
        if (_backlogs.Length > 0)
            _path = _backlogs[0];
        _mode = AggregateMode.Week;
        _velocityMode = VelocityMode.StoryPoints;
        _startDate = DateTime.Today.AddDays(-84);
        _targetPoints = 100;
        _efficiency = 80;
        _errorRange = 10;
        _periods.Clear();
        _iterations.Clear();
        _burnSeries.Clear();
        _flowSeries.Clear();
        await StateService.ClearAsync(StateKey);
        StateHasChanged();
    }

    private static DateTime StartOfWeek(DateTime dt)
    {
        int diff = (7 + (int)dt.DayOfWeek - (int)DayOfWeek.Monday) % 7;
        return dt.Date.AddDays(-diff);
    }

    private class PeriodMetrics
    {
        public string Name { get; set; } = string.Empty;
        public DateTime Start { get; set; }
        public DateTime End { get; set; }
        public double AvgLeadTime { get; set; }
        public double AvgCycleTime { get; set; }
        public int Throughput { get; set; }
        public double Velocity { get; set; }
        public double AvgWip { get; set; }
    }

    private class PageState
    {
        public string Path { get; set; } = string.Empty;
        public AggregateMode Mode { get; set; }
        public VelocityMode VelocityMode { get; set; }
        public DateTime? StartDate { get; set; }
        public double TargetPoints { get; set; }
        public double Efficiency { get; set; }
        public double Error { get; set; }
    }

    protected override Task OnProjectChangedAsync()
    {
        return OnInitializedAsync();
    }
}
